/*******************************************************************************
 * Copyright (c) 2018 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Alexander Kaiser
 *   Sascha Hackel
 *   Axel Rennoch
 *******************************************************************************/
module MQTTasp_PortType {

import from MQTT_TestSystem_Common all;
import from IPL4asp_PortType all;
import from IPL4asp_Types all;

import from MQTT_v3_1_1_IPL4SizeFunction all;
import from MQTT_v3_1_1_Types all;

import from MQTTasp_Types all;


//Dual faced port
type port MQTTasp_PT message {
  out charstring
  in MQTT_ASP_Event
  inout MQTTasp_Message
} with {
  extension "user IPL4asp_PT
  out(
  MQTTasp_Message -> ASP_SendTo   : function(f_enc_mqtt);
  charstring      -> ASP_Send     : function(f_enc_asp_send)
  )in(
  ASP_RecvFrom -> MQTTasp_Message  : function(f_dec_mqtt);
  ASP_Event    -> MQTT_ASP_Event   : function(f_dec_asp_event);
  ASP_ConnId_ReadyToRelease ->       - : discard
  )"
}

private function f_enc_mqtt(in MQTTasp_Message p_in, out ASP_SendTo p_out) return integer
{
  //log("[TRPO](Ecndode MQTT message): ", p_in)

  var octetstring v_encoded := f_MQTT_enc(p_in.msg);
  v_encoded := f_adjustLength(f_calc_rem_length(v_encoded));

  p_out.connId := p_in.conn.ipl4.id;
  p_out.remName := p_in.conn.ipl4.remote_name;
  p_out.remPort := p_in.conn.ipl4.remote_port;
  p_out.proto := {tcp := {}}    // TDOO: add proto to IPL4_Connection?
  p_out.msg := v_encoded;

  return 0;
  //} with {extension "prototype(fast)"}
} with {extension "prototype(backtrack)" }

private function f_dec_mqtt(in ASP_RecvFrom p_in, out MQTTasp_Message p_out) return integer
{
  log("[TRPO](Decode ASP_RecvFrom): ", p_in)

  var MQTT_v3_1_1_Message v_mqttMsg;
  //v_mqttMsg := f_MQTT_decode(p_in.msg)  // f_MQTT_decode is autogenerated and thus errorneous
  var integer v_dec_result := f_MQTT_v3_1_1_dec(p_in.msg, v_mqttMsg)

  if(v_dec_result == 1)
  {
    // decoding failed, try autogenerated decoder instead as fallback solution
    log("f_MQTT_v3_1_1_dec failed to decode. Use f_MQTT_decode as fallback decoder")
    v_mqttMsg := f_MQTT_decode(p_in.msg)
  }

  //log("[TRPO](Decoding Result): ", v_mqttMsg)
  if (ischosen(v_mqttMsg.msg)) {
    p_out.msg := v_mqttMsg;
    p_out.conn.ipl4.id := p_in.connId;
    p_out.conn.ipl4.remote_name := p_in.remName;
    p_out.conn.ipl4.remote_port := p_in.remPort;
    p_out.conn.ipl4.tcp_state := Connected
    p_out.conn.client_state := omit
    //log("[TRPO](Decoded MQTT message): ", p_out)
    return 0
  } else {
    //log("[TRPO](Error decoding): ", v_mqttMsg)
    return -1
  }
  //} with {extension "prototype(fast)"}
} with {extension "prototype(backtrack)" }

private function f_enc_asp_send(in charstring p_in, out ASP_Send p_out) return integer
{
  //log("[TRPO](Encode ASP Event): ", p_in)
  return 0;
  //} with {extension "prototype(fast)"}
} with {extension "prototype(backtrack)" }

private function f_dec_asp_event(in ASP_Event p_in, out MQTT_ASP_Event p_out) return integer
{
  //log("[TRPO](Decode ASP Event): ", p_in)
  p_out := p_in

  return 0;
  //} with {extension "prototype(fast)"}
} with {extension "prototype(backtrack)" }

// TODO: pass vl_connections as inout paramater and remove runs on
function f_add_connection(MQTT_Connection p_mqtt_con, MQTT_ClientState p_client_state := Wait_connack) runs on MQTT_Broker_MTC
{
  f_change_connection_client_state(p_mqtt_con, p_client_state);
  var integer v_conn_id := p_mqtt_con.ipl4.id;
  vl_connections[v_conn_id] := p_mqtt_con;
}

// TODO: define MQTT_Connection module with own OOP-like functions? functions which work only on MQTT_Connection and has no runs on
function f_change_connection_client_state(inout MQTT_Connection p_mqtt_con, MQTT_ClientState p_client_state)
{
  // TODO: check if connection already in vl_connections... ?
  p_mqtt_con.client_state := p_client_state
}

/*
* TODO:
* This function is a workaround: calling f_MQTT_enc(..) seems not to calculate the remLength field
*
* TODO: duplicate function also in MQTT_Functions
*
* TODO: check byte encoding from MQTT 2.2.3 (http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718023)
*/
function f_calc_rem_length(in octetstring p_os) return octetstring
{
  // cut 1 Byte Packet Type + 4 Byte empty remLength
  var integer v_remLength := lengthof(p_os) - 5;
  p_os := replace(p_os, 1, 4, int2oct(v_remLength, 4));

  return p_os;
}

} // module
