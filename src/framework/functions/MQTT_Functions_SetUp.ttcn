/*******************************************************************************
 * Copyright (c) 2018 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Alexander Kaiser
 *   Sascha Hackel
 *   Axel Rennoch
 *******************************************************************************/
module MQTT_Functions_SetUp
{
  import from MQTT_TestSystem_Common all;
  import from MQTT_TypesAndValues_Common all;

  import from MQTT_Templates_MQTTasp all;
  import from MQTT_Templates_CONNACK all;
  import from MQTT_Templates_DISCONNECT all;

  import from MQTT_Pixits all;
  import from MQTT_Broker_Pixits all;
  import from MQTT_Defaults_Common all;

  import from MQTT_Functions_Network all;
  import from MQTT_Functions_Protocol all;

  import from IPL4asp_Types all;

  group Broker
  {
    /*
    * initialize a broker MTC
    * @return
    */
    function f_init_broker() runs on MQTT_Broker_MTC return boolean
    {
      log("[INIT](Initialize MQTT Broker PTC)")
      map(self:MQTT_PCO, system:IPL4_PCO);

      var Result vl_result := f_ipl4_listen(p_port := PX_LISTEN_PORT);

      if (not(ispresent(vl_result.connId)))
      {
        log("[INIT](Could not connect TCP/TLS)");

        // TODO: test this case...
        // see https://github.com/eclipse/iottestware.mqtt/commit/1767d6bca1ef3e3958e05adf6e444b6d86f8ad9d
        stop;
      }

      // TODO: check if PX_MAX_TC_TIMER < 0.0 ??
      //if (PX_MAX_TC_TIMER > 0.0) { vl_testcase_max := PX_MAX_TC_TIMER }

      // TODO: check result
      ctx.connId := vl_result.connId
      vl_connections := {}

      // start timer and activate the default behavior
      tc_testcase_max.start;
      vc_timeout_default := activate(a_timeout_default(tc_testcase_max, PX_ON_TIMEOUT_VERDICT, PX_ON_TIMEOUT_VERDICT_VAL))

      return true;
    }

    function f_clear_broker() runs on MQTT_Broker_MTC
    {
      log("[CLR](Clear MQTT Broker PTC)")

      // deactivate the default timeout behavior
      deactivate(vc_timeout_default);

      // cleanly disconnect all connections
      f_disconnect_all();

      unmap(self:MQTT_PCO, system:IPL4_PCO);
      self.stop;
    }
  } // group Broker

  group Client
  {

    /*
    * @desc initialize the whole MQTT Client Test System
    */
    function f_init_client_system(inout MQTT_Client_MTC p_ptc_1, inout MQTT_Client_MTC p_ptc_2) system MQTT_Client_TestSystem
    return BooleanReturnType
    {
      var BooleanReturnType v_init_ptc_1, v_init_ptc_2;

      map(p_ptc_1:MQTT_PCO, system:mqtt_client_1)
      map(p_ptc_2:MQTT_PCO, system:mqtt_client_2)

      p_ptc_1.start(f_init_client(0));
      p_ptc_2.start(f_init_client(1));

      // wait until clients initialized and store the init state
      p_ptc_1.done(BooleanReturnType : ?) -> value v_init_ptc_1
      p_ptc_2.done(BooleanReturnType : ?) -> value v_init_ptc_2

      if(v_init_ptc_1 and v_init_ptc_2)
      {
        return true
      }
      else
      {
        return false
      }
    }

    /*
    * @desc initialize one single MQTT Client
    */
    function f_init_client(in integer p_client_idx) runs on MQTT_Client_MTC
    return BooleanReturnType
    {
      if(p_client_idx < 0 or p_client_idx >= lengthof(PX_CLIENTS))
      {
        log("Client Index ", p_client_idx, " is out of range")
        setverdict(inconc, "Initialization failed: check your config")
        return false
      }

      connection := {
        ipl4 := {
          id := -1,
          remote_name := PX_SUT_HOSTNAME,
          remote_port := PX_SUT_PORT,
          local_name := PX_LOCAL_HOST_ADDRESS,
          local_port := -1,
          reuse_address := PX_REUSE_ADDRESS,
          tcp_state := Disconnected
        },
        client_state := Disconnected
      }

      credentials := PX_CLIENTS[p_client_idx]

      return true
    }

    /*
    * @desc clean up the whole MQTT Client Test System
    */
    function f_clear_client_system(inout MQTT_Client_MTC p_ptc_1, inout MQTT_Client_MTC p_ptc_2) system MQTT_Client_TestSystem
    return BooleanReturnType
    {
      var BooleanReturnType v_clear_ptc_1, v_clear_ptc_2;

      p_ptc_1.start(f_clear_client())
      p_ptc_2.start(f_clear_client())

      // wait until clients initialized and store the init state
      p_ptc_1.done(BooleanReturnType : ?) -> value v_clear_ptc_1
      p_ptc_2.done(BooleanReturnType : ?) -> value v_clear_ptc_2
      all component.kill

      unmap(p_ptc_1:MQTT_PCO, system:mqtt_client_1)
      unmap(p_ptc_2:MQTT_PCO, system:mqtt_client_2)

      return true
    }

    /*
    * @desc clean up one single MQTT Client
    */
    function f_clear_client() runs on MQTT_Client_MTC
    return BooleanReturnType
    {
      // TODO: any further clean up required?
      f_send_disconnect(true);
      return true
    }
  } // group Client

} // module
