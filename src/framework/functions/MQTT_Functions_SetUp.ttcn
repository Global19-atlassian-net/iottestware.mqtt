/*******************************************************************************
 * Copyright (c) 2018 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Alexander Kaiser
 *   Sascha Hackel
 *   Axel Rennoch
 *******************************************************************************/
module MQTT_Functions_SetUp
{
  import from MQTT_TestSystem_Common all;

  import from MQTT_Templates_MQTTasp all;
  import from MQTT_Templates_CONNACK all;
  import from MQTT_Templates_DISCONNECT all;

  import from MQTT_Broker_Pixits all;
  import from MQTT_Defaults_Common all;

  import from MQTT_Functions_Network all;
  import from MQTT_Functions_Protocol all;

  import from IPL4asp_Types all;

  group Broker
  {
    /*
    * initialize a broker MTC
    * @return
    */
    function f_init_broker() runs on MQTT_Broker_MTC return boolean
    {
      log("[INIT](Initialize MQTT Broker PTC)")
      map(self:MQTT_PCO, system:IPL4_PCO);

      var Result vl_result := f_ipl4_listen(p_port := PX_LISTEN_PORT);

      if (not(ispresent(vl_result.connId)))
      {
        log("[INIT](Could not connect TCP/TLS)");

        // TODO: test this case...
        // see https://github.com/eclipse/iottestware.mqtt/commit/1767d6bca1ef3e3958e05adf6e444b6d86f8ad9d
        stop;
      }

      // TODO: check if PX_MAX_TC_TIMER < 0.0 ??
      //if (PX_MAX_TC_TIMER > 0.0) { vl_testcase_max := PX_MAX_TC_TIMER }

      // TODO: check result
      ctx.connId := vl_result.connId
      vl_connections := {}

      // start timer and activate the default behavior
      tc_testcase_max.start;
      vc_timeout_default := activate(a_timeout_default(tc_testcase_max, PX_ON_TIMEOUT_VERDICT, PX_ON_TIMEOUT_VERDICT_VAL))

      return true;
    }

    function f_clear_broker() runs on MQTT_Broker_MTC
    {
      log("[CLR](Clear MQTT Broker PTC)")

      // deactivate the default timeout behavior
      deactivate(vc_timeout_default);

      // cleanly disconnect all connections
      f_disconnect_all();

      map(self:MQTT_PCO, system:IPL4_PCO);
      self.stop;
    }
  } // group Broker

  group Client
  {
    import from MQTT_Pixits all;

    function f_init_client(in integer p_client_idx) runs on MQTT_Client_MTC
    {
      if(p_client_idx < 0 or p_client_idx >= lengthof(PX_CLIENTS))
      {
        log("Client Index ", p_client_idx, " is out of range")
        self.kill
      }

      connection := {
        ipl4 := {
          id := -1,
          remote_name := PX_SUT_HOSTNAME,
          remote_port := PX_SUT_PORT,
          local_name := PX_LOCAL_HOST_ADDRESS,
          local_port := -1,
          reuse_address := PX_REUSE_ADDRESS,
          tcp_state := Disconnected
        },
        client_state := Disconnected
      }

      credentials := PX_CLIENTS[p_client_idx]
    }

    function f_clear_client() runs on MQTT_Client_MTC return boolean
    {
      return true // TODO
    }
  } // group Client

} // module
