

module Playground
{
  import from MQTT_TestSystem_Common all;
  import from MQTT_v3_1_1_Types all;
  import from MQTT_Templates_CONNECT all;
  import from MQTT_Defaults_Common all;
  import from MQTT_Functions_Network all;

  import from MQTTasp_PortType all;
  import from MQTTasp_Types all;
  import from MQTTasp_CtrlFunct all;

  import from IPL4asp_PortType all;
  import from IPL4asp_Types all;

  import from Random_Helper all;

  /*
   * test matching bahviour used in f_MQTT_Client_CONNECT_08
   */
  testcase TCU_Client_CONNECT_08() runs on MQTT_Broker_MTC
  {
    var MQTT_v3_1_1_ConnectPayload v_input :=
    {
      client_identifier :=
      {
        stringLength := 23,
        stringItem := "TS7QVyCxbSK+aDkbDT3Zy5A"
      },
      will_topic := omit,
      will_message := omit,
      user_name := omit,
      password := omit
    }

    log("[TEMPL]: ", mw_connect_payload)
    log("[INPUT]:", v_input)
    log("[TEMPL]: ", mw_connect_payload_credentials_empty)
    //if(match(v_input, mw_connect_payload_credentials_empty))
    if(match(valueof(v_input), mw_connect_payload))
    {
      setverdict(pass)
    } else {
      setverdict(fail)
    }
  }

  /*
   * test case for building a mtc controlled test
   *
   *    +----------------+              +----------------+
   *    |                |            * |                |
   *    |      MTC       +-------------->      PTC       |
   *    |                |              |                |
   *    +----------------+              +----------------+
   *
   * MTC (Main Test Component) controls multiple PTC (Parallel Test Component)
   */

   testcase TC_Exp_MTC_01() runs on MQTT_Client_MTC system MQTT_Client_TestSystem
   {
     var MQTT_Client_MTC publisher, subscriber;

     publisher := MQTT_Client_MTC.create("Publisher")
     subscriber := MQTT_Client_MTC.create("Subscriber")

     map(publisher:MQTT_PCO, system:MQTT_Publisher)
     map(subscriber:MQTT_PCO, system:MQTT_Subscriber)

     publisher.start(f_behavior_01());
     subscriber.start(f_behavior_01());

     publisher.done;
     subscriber.done;

     unmap(publisher:MQTT_PCO, system:MQTT_Publisher)
     unmap(subscriber:MQTT_PCO, system:MQTT_Subscriber)
   }

   function f_behavior_01() runs on MQTT_Client_MTC
   {
     timer t_timeout := 5.0;
     t_timeout.start

     if(f_ipl4_connect())
     {
       log("### BEHAVIOR 01: connected")

       alt {
         [] t_timeout.timeout {
           setverdict(pass)
           f_ipl4_close(ctx.connId)
           break;
         }
       }
     }
     else
     {
       log("### BEHAVIOR 01: NOT connected")
       setverdict(fail)
     }
   }

   function f_behavior_02() runs on MQTT_Client_MTC
   {
     timer t_timeout := 5.0;
     t_timeout.start

     if(f_ipl4_connect())
     {
       log("+++ BEHAVIOR 02: connected")

       alt {
         [] t_timeout.timeout {
           setverdict(pass)
           break;
         }
       }
     }
     else
     {
       log("+++ BEHAVIOR 02: NOT connected")
       setverdict(fail)
     }
   }
}
