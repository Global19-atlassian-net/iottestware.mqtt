/*******************************************************************************
 * Copyright (c) 2018 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html 
 *
 * Contributors:
 *   Alexander Kaiser
 *    Sascha Hackel
 *******************************************************************************/
module MQTT_Broker_AltSteps {

import from MQTT_Common_TestSystem all;
import from MQTT_Common_Templates all;
import from MQTT_Templates all;
import from MQTT_Broker_Templates all;
import from MQTT_Broker_Functions all;

import from MQTTasp_CtrlFunct all;

import from MQTTasp_Types all;
import from IPL4asp_Types all;

altstep a_mqtt_connack_default(timer p_timer) runs on MQTT_Broker_PTC {

  var MQTTasp_Message v_received;
  var template MQTTasp_Message vt_connect_valid := tw_mqtt_message(tw_connect_valid_mqtt_311);
  var template MQTTasp_Message vt_connect_all := tw_mqtt_message(tw_connect);

  [] MQTT_PCO.receive(vt_connect_valid) -> value v_received {
    log("[ALT](Valid CONNECT received): ", v_received)

    var MQTT_Connection v_con := v_received.conn

    var template MQTTasp_Message vt_connack_resp := t_mqtt_message_conn(t_connack, v_con)
    MQTT_PCO.send(valueof(vt_connack_resp)) // send CONNACK response

    // TODO: verify
    var integer v_conn_id := v_received.conn.ipl4.id
    v_con.client_state := Connected
    vl_connections[v_conn_id] := v_con
    repeat;
  }
  [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
    log("[ALT](Invalid CONNECT received): ", v_received)

    // TODO: implement function f_reject_connection(boolean withDisconnectReq)
    // for easier handling of invalid client bahavior
    var MQTT_Connection v_con := v_received.conn
    v_con.client_state := Wait_connack
    f_add_connection(v_con)
    f_disconnect_single(v_con.ipl4.id);
    
    setverdict(fail, "Received invalid CONNECT")
    break;
  }
  [] p_timer.timeout {
    break;
  }
}

altstep a_mqtt_disconnect_default(timer p_timer) runs on MQTT_Broker_PTC {
  var MQTTasp_Message v_received;
  var template MQTTasp_Message vt_disconnect_req := tw_mqtt_message(tw_disconnect);

  [] MQTT_PCO.receive(vt_disconnect_req) -> value v_received {
    log("[ALT](Disconnect default triggered for): ", v_received)

    var integer v_conn_id := v_received.conn.ipl4.id
    var MQTT_Connection v_con := vl_connections[v_conn_id]

    // close the IPL4 connection
    var Result v_res := f_IPL4_close(MQTT_PCO, v_con.ipl4.id)
    log("[ALT](Disconnect IPL4 connect): ", v_res)

    v_con.client_state := Disconnected
    v_con.ipl4.tcp_state := Disconnected

    break;
  }
  [] p_timer.timeout {
    break;
  }
}

} // module
