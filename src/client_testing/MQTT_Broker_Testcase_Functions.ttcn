/*******************************************************************************
* Copyright (c) 2018 Relayr GmbH
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*   Alexander Kaiser
*   Sascha Hackel
*   Axel Rennoch
*******************************************************************************/
module MQTT_Broker_Testcase_Functions {

import from MQTT_TestSystem_Common all;

// defaults
import from MQTT_Defaults_CONNACK all;

// PIXITs
import from MQTT_Broker_Pixits all;

// Functions
import from MQTT_Functions_Conformance all;
import from MQTT_Functions_Protocol all;
import from MQTTasp_PortType all;

// Types
import from MQTTasp_Types all;
import from MQTT_v3_1_1_Types all;

// Templates
import from MQTT_Templates_MQTTasp all;
import from MQTT_Templates_CONNECT all;
import from MQTT_Templates_CONNACK all;
import from MQTT_Templates_PUBLISH all;
import from MQTT_Templates_PUBACK all;
import from MQTT_Templates_PUBREC all;
import from MQTT_Templates_PUBREL all;
import from MQTT_Templates_PUBCOMP all;
import from MQTT_Templates_SUBSCRIBE all;
import from MQTT_Templates_UNSUBSCRIBE all;
import from MQTT_Templates_PINGREQ all;
import from MQTT_Templates_DISCONNECT all;

// Upper Tester
import from UT_Types all;
import from UT_Templates all;
import from UT_Functions all;

import from UTF8_Helper all;
import from Random_Helper all;

group connectGroup
{

  /*
  *
  */
  function f_MQTT_Client_CONNECT_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check Header flags"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_01(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        // [TC_*] logging forwarded to the webserver can enrich resoult
        log("[TC_MQTT_Client_CONNECT_01](received connect): ", v_received.msg.msg.connect_msg)

        if (match(v_received.msg.msg.connect_msg.header, mw_connect_header)) {
          f_send_connack(v_conn)
          setverdict(pass, "Header flags checked")
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Header flags must be set to '0000'B")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check Protocol name"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_02(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if (f_connect_protocol_name_valid(v_received.msg.msg.connect_msg) or PX_ACCEPT_ANY_PROTOCOL_NAME) {
          f_send_connack(v_conn)

          log("[TC_MQTT_Client_CONNECT_02](received connect): ", v_received.msg.msg.connect_msg)

          // [MQTT-3.1.2-1] allows also to accept any other protocol names: configure PX_ACCEPT_ANY_PROTOCOL_NAME
          if (PX_ACCEPT_ANY_PROTOCOL_NAME) {
            setverdict(pass, "TS Broker accepts any protocol name")
          } else {
            setverdict(pass, "Protocol name checked")
          }
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Protocol name must be UTF-8 encoded 'MQTT'")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_03() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check Protocol level"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_03(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_03](received connect): ", v_received.msg.msg.connect_msg)

        if (f_connect_protocol_lvl_valid(v_received.msg.msg.connect_msg)) {
          f_send_connack(v_conn)
          setverdict(pass, "Protocol level checked")
        } else {
          f_unacceptable_protocol(v_conn)
          setverdict(fail, "Protocol level for MQTT v3.1.1 must be 4")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_04() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check Reserved flag"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_04(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_04](received connect): ", v_received.msg.msg.connect_msg)

        if (f_connect_flags_reserved_valid(v_received.msg.msg.connect_msg.flags)) {
          f_send_connack(v_conn)
          setverdict(pass, "Reserved flag checked")
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Reserved flag must be set to '0'")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_05() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check LWT flag"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_05(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_05](received connect): ", v_received.msg.msg.connect_msg)

        // TODO: check the will flag -> outsource to conformance function
        if (match(v_received.msg, mw_connect_will_flag)) {

          // TODO: outsource to separate conformance function
          var QoS vt_invalid_qos := RESERVED
          if(match(vt_invalid_qos, v_received.msg.msg.connect_msg.flags.will_qos))
          {
            // Note: inverted match -> vt_INVALID_qos
            f_terminate_due_to_violation(v_conn)
            setverdict(fail, "Received CONNECT contains invalid Will Qos")
          } else {
            f_send_connack(v_conn)
            setverdict(pass, "Will flag and Will QoS checked")
          }
        } else {
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Will flag must be set to '1'")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_06() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check LWT flags"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_06(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)


    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_06](received connect): ", v_received.msg.msg.connect_msg)

        if(match(v_received.msg, mw_connect_will_flag)) {

          // pre set to pass and decrease to fail if some missbehavious found
          setverdict(pass, "Will flag and Will QoS checked")

          // check if will_qos is valid
          //TODO: mw_connect_will_flag matching only valid?
          var QoS vt_invalid_qos := RESERVED
          if(match(vt_invalid_qos, v_received.msg.msg.connect_msg.flags.will_qos)){
            setverdict(fail, "Received CONNECT contains Will Qos == 3")
          }

          // check if will_retain
          //TODO: mw_connect_will_flag matching only valid?
          if(match('1'B, v_received.msg.msg.connect_msg.flags.will_retain)) {
            setverdict(fail, "Received CONNECT contains will_retain but will_flag is '0'B")
          }

          // check if connect payload is empty
          var template MQTT_v3_1_1_ConnectPayload vt_conn_payload := mw_connect_payload_lwt_empty
          if(match(v_received.msg.msg.connect_msg.payload, vt_conn_payload)) {
            setverdict(fail, "Received CONNECT contains LWT payload but will_flag is '0'B")
          }

          if(getverdict == pass) {
            f_send_connack(v_conn)
            //setverdict(pass, "Will flag and Will QoS checked")
          } else {
            // close network connection; already failed
            f_terminate_due_to_violation(v_conn)
          }

        } else {
          // close network connection
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Will flag must be set to '1'")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_07() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check empty credentials"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_07(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_07](received connect): ", v_received.msg.msg.connect_msg)

        if (match(v_received.msg.msg.connect_msg.flags, mw_connect_credentials_empty.msg.connect_msg.flags)) {
          f_send_connack(v_conn)
          setverdict(pass, "No credentials behaviour checked")
        } else {
          // close network connection
          f_send_connack(v_conn, 5) // not authorized to connect
          setverdict(fail, "not match (usr_flag='0'B : pswd_flag='0'B : payload=omit)")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_08() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    var BIT1n v_user_name_flag := '1'B
    var BIT1n v_password_flag := '0'B
    var template MQTT_v3_1_1_Message vt_conn_msg := mw_connect_credentials_payload(v_user_name_flag, v_password_flag)

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check username without password"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_08(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_08](received connect): ", v_received.msg.msg.connect_msg)

        // TODO: matching omits? see Playground.TCU_Client_CONNECT_08
        if (not ispresent(v_received.msg.msg.connect_msg.payload.user_name))
        {
          setverdict(fail, "No user name in payload")
        }

        if (ispresent(v_received.msg.msg.connect_msg.payload.password))
        {
          setverdict(fail, "pswd flag is '0'B but payload contains pswd")
        }

        if (getverdict == fail)
        {
          // close network connection
          f_terminate_due_to_violation(v_conn)
        } else {
          f_send_connack(v_conn)
          setverdict(pass, "Username set correctly")
        }
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_09() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    var BIT1n v_user_name_flag := '1'B
    var BIT1n v_password_flag := '1'B
    var template MQTT_v3_1_1_Message vt_conn_msg := mw_connect_credentials_payload(v_user_name_flag, v_password_flag)

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check for credentials"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_09(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_09](received connect): ", v_received.msg.msg.connect_msg)

        if (not ispresent(v_received.msg.msg.connect_msg.payload.user_name))
        {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "uesr_name flag is '1'B but payload dosn't contain user_name")
        }

        if (not ispresent(v_received.msg.msg.connect_msg.payload.password))
        {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "password flag is '1'B but payload dosn't contain a password")
        }

        if (getverdict == fail)
        {
          // close network connection
          f_terminate_due_to_violation(v_conn)
        } else {
          f_send_connack(v_conn)
          setverdict(pass, "Username and Passwort set correctly")
        }
      }
    } // alt
  }

  /*
  *
  * @remark by comparing each field with the sent values, the order is checked implicitly.
  *         Wrong order would silently swap the fields during decoding
  */
  function f_MQTT_Client_CONNECT_10() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received

    var UTF8EncodedString v_client_id := f_utf8_from_charstring(PX_CLIENT_ID);
    var UTF8EncodedString v_will_topic := f_utf8_from_charstring(PX_WILL_TOPIC);
    var OctStringWithLength v_will_msg := { stringLength := lengthof(PX_WILL_MESSAGE), stringItem := unichar2oct(PX_WILL_MESSAGE) };
    var UTF8EncodedString v_user_name := f_utf8_from_charstring(PX_USER_NAME);
    var OctStringWithLength v_password := { stringLength := lengthof(PX_PASSWORD), stringItem := unichar2oct(PX_PASSWORD) }

    var template MQTT_v3_1_1_Message vt_conn_msg := m_connect_credentials_payload_lwt(v_client_id, v_will_topic, v_will_msg, v_user_name, v_password)
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check connect payload fields"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_10(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);
        f_send_connack(v_conn)

        log("[TC_MQTT_Client_CONNECT_10](received connect): ", v_received.msg.msg.connect_msg)
        setverdict(pass, "Order of fields in CONNECT Payload checked")
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        log("Received unexpected PDU: ", v_received)
        // TODO: f_terminate_due_to_violation(v_conn)  // NOTE: not conformant response!! checking all fields would be still required here!
        setverdict(fail, "received unexpected PDU")
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_11() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check if client ID is valid"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_11(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(ispresent(v_received.msg.msg.connect_msg.payload.client_identifier))
        {
          var UTF8EncodedString v_client_id := v_received.msg.msg.connect_msg.payload.client_identifier
          if(f_client_id_valid(v_client_id))
          {
            f_send_connack(v_conn)
            setverdict(pass, "Client ID ", v_client_id.stringItem, " is valid")
          }
          else
          {
            f_terminate_due_to_violation(v_conn)
            setverdict(fail, "Client ID ", v_client_id.stringItem, " is invalid")
          }
        }
        else
        {
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "No Client ID was given")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    } // alt
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_12() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check if client ID is valid UTF-8"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_12(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        /*
         * Note:
         * single specific and (probably) not reusable case and therefore not in MQTT_Functions_Conformance.ttcn
         * This way the verdict message is more precise
         */
        log("[MQTT_v4][checked]: {[MQTT-3.1.3-7]}")

        // if(match(v_received.msg, mdw_connect_msg_clean_session)) <- does not match directly!
        if(match(v_received.msg.msg.connect_msg.payload.client_identifier, mdw_connect_msg_clean_session.msg.connect_msg.payload.client_identifier))
        {
          if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_msg_clean_session.msg.connect_msg.flags))
          {
            f_send_connack(v_conn)
            setverdict(pass, "Empty Client ID and Clean Session flag set correctly")
          }
          else
          {
            f_send_connack(v_conn, 2) // [MQTT-3.1.3-9]
            f_terminate_due_to_violation(v_received.conn)
            setverdict(fail, "Client ID is empty but Clean Session flag is not set")
          }
        }
        else
        {
          setverdict(fail, "Client ID is not empty")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_13() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check if the will topic is valid UTF-8"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_13(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_will_flag))
        {
          if(ispresent(v_received.msg.msg.connect_msg.payload.will_topic))
          {
            var UTF8EncodedString v_will_topic := v_received.msg.msg.connect_msg.payload.will_topic;
            if(f_topic_valid(v_will_topic))
            {
              f_send_connack(v_conn)
              setverdict(pass, "Will Topic is valid UTF-8")
            }
            else
            {
              f_terminate_due_to_violation(v_received.conn)
              setverdict(fail, "Will Topic is invalid UTF-8")
            }
          }
          else
          {
            setverdict(fail, "Will Topic is not present")
          }
        }
        else
        {
          setverdict(fail, "Will flag is not set")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_CONNECT_14() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // trigger the upper tester
    var charstring v_free_text := "Please send CONNECT to check if the user name is valid UTF-8"
    var template MQTT_UT_Message v_trigger := m_ut_client_connect_14(PX_LISTEN_HOSTNAME, PX_LISTEN_PORT, v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_credentials_username))
        {
          // TODO: decoding of MQTT payload seems to be incorrect!
          if(ispresent(v_received.msg.msg.connect_msg.payload.user_name))
          {
            if(f_username_valid(v_received.msg.msg.connect_msg.payload.user_name))
            {
              f_send_connack(v_conn)
              setverdict(pass, "Username is valid UTF-8")
            }
            else
            {
              f_terminate_due_to_violation(v_received.conn)
              setverdict(fail, "Username is invalid UTF-8")
            }
          }
          else
          {
            setverdict(fail, "Username is not present in connect payload")
          }
        }
        else
        {
          setverdict(fail, "Username flag is not set")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_CONNACK_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message v_connect := mw_mqtt_message(mdw_connect_valid_mqtt_x)
    // Initial condition: trigger the upper tester to connect without responding with CONNACK
    f_ut_initial_connect_03()

    alt {
      [] MQTT_PCO.receive(v_connect) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        var template MQTT_v3_1_1_Message v_connack := m_connack_rc_header_flags('1111'B, 0)

        timer t_timeout := PX_AWAIT_NO_RESPONSE_TIMER // TODO: new timer required here? or just give it a better more generic name?
        t_timeout.start
        f_send_mqtt(v_conn, v_connack)
        alt {
          [] MQTT_PCO.receive(MQTT_ASP_Event:?) {
            setverdict(pass, "IUT closed network connection correctly")
          }
          [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
            setverdict(fail, "IUT must not send any further messages and close network connection")
          }
          [] t_timeout.timeout {
            setverdict(fail, "IUT did not close the network connection")
          }
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "unexpected PDU")
      }
    }
  }
} // group connectGroup

group publishGroup
{
  /*
  *
  */
  function f_MQTT_Client_PUBLISH_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    //var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)

    // Initial condition: trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 0
    var charstring v_free_text := "Please send PUBLISH with QoS 0"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_01(v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(AT_MOST_ONCE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          if(match(v_received.msg.msg.publish.header.dup_flag, '0'B))
          {
            setverdict(pass, "received PUBLISH with QoS 0 and DUP 0")
          }
          else
          {
            setverdict(fail, "received PUBLISH has wrong DUP")
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "unexpected PDU")
      }
    }

    //deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)
    timer t_retransmission := PX_PUB_RETRANSMISSION_TIMER

    // Initial condition: trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send PUBLISH with QoS 1"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_02(v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(AT_LEAST_ONCE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          t_retransmission.start
          if(v_received.conn.client_state != Wait_publish)
          {
            // NOTE: drop the first publish packet and set client state to
            // dropping the packet should enforce re-transmission
            f_change_connection_client_state(v_received.conn, Wait_publish)
            repeat;
          }
          else
          {
            if(match(v_received.msg.msg.publish.header.dup_flag, '1'B))
            {
              f_send_puback(v_received.conn, v_received.msg.msg.publish.packet_identifier)
              setverdict(pass, "received PUBLISH with QoS 1 and DUP 1")
            }
            else
            {
              setverdict(fail, "received PUBLISH has wrong DUP")
            }
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
      [] t_retransmission.timeout {
        setverdict(fail, "no retransmission of PUBLISH with DUP 1")
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_03() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)
    timer t_retransmission := PX_PUB_RETRANSMISSION_TIMER

    // Initial condition: trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send PUBLISH with QoS 2"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_03(v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(EXACTLY_ONE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          if(v_received.conn.client_state != Wait_publish)
          {
            // drop the first publish packet and set client state to
            f_change_connection_client_state(v_received.conn, Wait_publish)
            t_retransmission.start
            repeat;
          }
          else
          {
            if(match(v_received.msg.msg.publish.header.dup_flag, '1'B))
            {
              f_send_puback(v_received.conn, v_received.msg.msg.publish.packet_identifier)
              setverdict(pass, "received PUBLISH with QoS 2 and DUP 1")
            }
            else
            {
              setverdict(fail, "received PUBLISH has wrong DUP")
            }
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
      [] t_retransmission.timeout {
        setverdict(fail, "no retransmission of PUBLISH with DUP 1")
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_04() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)

    // Initial condition: trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send PUBLISH with a valid topic name"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_04(v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var UTF8EncodedString v_topic_name := f_utf8_from_charstring(v_received.msg.msg.publish.topic_name)
        if(f_is_valid_utf8(v_topic_name))
        {
          setverdict(pass, "Publish topic name is valid UTF-8")
        } else {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Publish topic name is invalid UTF-8")
        }
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_05() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)

    // Initial condition: trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with a valid topic name
    var charstring v_free_text := "Please send PUBLISH with a valid topic name"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_05(v_free_text)
    f_ut_trigger(v_trigger)

    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var UTF8EncodedString v_topic_name := f_utf8_from_charstring(v_received.msg.msg.publish.topic_name)
        if(f_topic_valid(v_topic_name))
        {
          setverdict(pass, "Publish topic name is valid")
        } else {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Publish topic name is invalid")
        }
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_06() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(AT_MOST_ONCE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet_qos_0(valueof(t_publish_header), v_topic, v_payload))
      f_send_publish(v_conn, v_publish)

      timer t_timer := PX_AWAIT_NO_RESPONSE_TIMER
      t_timer.start

      alt {
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "Received unexpected message ", v_received)
        }
        [] t_timer.timeout {
          setverdict(pass, "IUT correctly send no response")
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_07() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(AT_MOST_ONCE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := AT_LEAST_ONCE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_puback_packet_id(v_packet_id))

      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "IUT respond correctly with PUBACK")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_08() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(AT_MOST_ONCE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := EXACTLY_ONE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_pubrec_packet_id(v_packet_id))

      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "IUT respond correctly with PUBREC")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_09() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received

    // trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send a PUBLISH"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_09(v_free_text)
    f_ut_trigger(v_trigger)

    // expected behaviour
    alt {
      [] MQTT_PCO.receive(mw_mqtt_message(mdw_publish_qos(AT_LEAST_ONCE_DELIVERY))) -> value v_received {
        var integer v_packet_id := v_received.msg.msg.publish.packet_identifier
        if(v_packet_id > 0) {
          setverdict(pass, "IUT sent PUBLISH with valid packet identifier")
        } else {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "PUBLISH with QoS > 0 must have a non-zero packet identifier")
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "IUT respond with unexpected message ", v_received)
        break
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_10() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received

    // trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send a PUBLISH"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_10(v_free_text)
    f_ut_trigger(v_trigger)

    // expected behaviour
    alt {
      [] MQTT_PCO.receive(mw_mqtt_message(mdw_publish_qos(AT_LEAST_ONCE_DELIVERY))) -> value v_received {
        v_free_text := "Please send a second PUBLISH"
        v_trigger := m_ut_client_publish_09(v_free_text)
        f_ut_trigger(v_trigger)
        var integer v_prev_packet_id := v_received.msg.msg.publish.packet_identifier
        alt {
          [] MQTT_PCO.receive(mw_mqtt_message(mdw_publish_qos(AT_LEAST_ONCE_DELIVERY))) -> value v_received {
            var integer v_next_packet_id := v_received.msg.msg.publish.packet_identifier
            if (v_prev_packet_id != v_next_packet_id) {
              // acknowledgeme both publish messages
              f_send_pub_response(v_received.conn, v_received.msg.msg.publish.header.qos_level, v_prev_packet_id)
              f_send_pub_response(v_received.conn, v_received.msg.msg.publish.header.qos_level, v_next_packet_id)
              setverdict(pass, "IUT assigned an unused packet identifier")
            } else {
              f_terminate_due_to_violation(v_received.conn)
              setverdict(fail, "IUT assigned an used packet identifier")
            }
            break
          }
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "IUT respond with unexpected message ", v_received)
        break
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_PUBLISH_11() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received

    // trigger the upper tester to connect
    f_ut_initial_connect_01()

    // trigger the upper tester to publish with QoS 1
    var charstring v_free_text := "Please send a PUBLISH"
    var template MQTT_UT_Message v_trigger := m_ut_client_publish_11(v_free_text)
    f_ut_trigger(v_trigger)

    // expected behaviour
    alt {
      [] MQTT_PCO.receive(mw_mqtt_message(mw_publish_message_qos0)) -> value v_received {
        setverdict(pass, "IUT sent correctly publish with QoS 0 and no packet identifier")
      }
      [] MQTT_PCO.receive(mw_mqtt_message(mw_publish_message_qos(AT_MOST_ONCE_DELIVERY))) -> value v_received {
        f_terminate_due_to_violation(v_received.conn)
        setverdict(fail, "Publish with QoS 0 must not have a packet identifier")
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "IUT respond with unexpected message ", v_received)
        break
      }
    }
  }

  /*
  *
  */
  function f_MQTT_Client_PUBACK_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(AT_LEAST_ONCE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := AT_LEAST_ONCE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_puback_header_flags('0000'B))
      var template MQTTasp_Message v_puback := mw_mqtt_message(mw_puback)

      timer t_response := PX_WAIT_FOR_RESPONSE_TIMER;
      t_response.start;
      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "Checked PUBACK reserved flags")
        }
        [] MQTT_PCO.receive(v_puback) -> value v_received {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Received invalid PUBACK")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
        [] t_response.timeout {
          setverdict(fail, "IUT did not send a PUBACK response")
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBACK_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(AT_LEAST_ONCE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := AT_LEAST_ONCE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_puback_packet_id(v_packet_id))
      var template MQTTasp_Message v_puback := mw_mqtt_message(mw_puback)

      timer t_response := PX_WAIT_FOR_RESPONSE_TIMER;
      t_response.start;
      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "Received PUBACK with correct packet identifier")
        }
        [] MQTT_PCO.receive(v_puback) -> value v_received {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Received invalid PUBACK")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
        [] t_response.timeout {
          setverdict(fail, "IUT did not send a PUBACK response")
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBREC_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(EXACTLY_ONE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := EXACTLY_ONE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_pubrec_header_flags('0000'B))
      var template MQTTasp_Message v_pubrec := mw_mqtt_message(mw_pubrec)

      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "Checked PUBREC reserved flags")
        }
        [] MQTT_PCO.receive(v_pubrec) -> value v_received {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Received invalid PUBREC")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBREC_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(EXACTLY_ONE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := EXACTLY_ONE_DELIVERY))
      var integer v_packet_id := f_random_packet_id()

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_pubrec_packet_id(v_packet_id))
      var template MQTTasp_Message v_pubrec := mw_mqtt_message(mw_pubrec)

      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          setverdict(pass, "Received PUBREC with correct packet identifier")
        }
        [] MQTT_PCO.receive(v_pubrec) -> value v_received {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Received invalid PUBREC")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBREL_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    var template MQTTasp_Message v_publish := mw_mqtt_message(mdw_publish_qos(EXACTLY_ONE_DELIVERY))

    // Initial condition: trigger the upper tester to connect and publish with QoS = 2
    f_ut_initial_connect_01()
    f_ut_publish(EXACTLY_ONE_DELIVERY)

    alt {
      [] MQTT_PCO.receive(v_publish) -> value v_received {
        var integer v_packet_id := v_received.msg.msg.publish.packet_identifier
        var template MQTT_v3_1_1_Message v_pubrec := m_pubrec(v_packet_id)
        var template MQTTasp_Message v_pubrel_exp := mw_mqtt_message(mw_pubrel)
        v_conn := v_received.conn
        f_send_mqtt(v_conn, v_pubrec)
        alt {
          [] MQTT_PCO.receive(v_pubrel_exp) -> value v_received {
            v_packet_id := v_received.msg.msg.pubrel.packet_identifier
            var template MQTT_v3_1_1_Message v_pubcomp := m_pubcomp(v_packet_id)
            f_send_mqtt(v_conn, v_pubcomp)
            setverdict(pass, "Checked PUBREL header flags")
          }
          [] MQTT_PCO.receive(MQTTasp_Message:?) {
            setverdict(fail, "IUT respond with unexpected message ", v_received)
          }
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "IUT respond with unexpected message ", v_received)
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBREL_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    var template MQTTasp_Message v_publish := mw_mqtt_message(mdw_publish_qos(EXACTLY_ONE_DELIVERY))

    // Initial condition: trigger the upper tester to connect and publish with QoS = 2
    f_ut_initial_connect_01()
    f_ut_publish(EXACTLY_ONE_DELIVERY)

    alt {
      [] MQTT_PCO.receive(v_publish) -> value v_received {
        var integer v_publish_packet_id := v_received.msg.msg.publish.packet_identifier
        var template MQTT_v3_1_1_Message v_pubrec := m_pubrec(v_publish_packet_id)
        var template MQTTasp_Message v_pubrel_exp := mw_mqtt_message(mw_pubrel)
        v_conn := v_received.conn
        f_send_mqtt(v_conn, v_pubrec)
        alt {
          [] MQTT_PCO.receive(v_pubrel_exp) -> value v_received {
            var integer v_pubrel_packet_id := v_received.msg.msg.pubrel.packet_identifier
            if(v_pubrel_packet_id == v_publish_packet_id) {
              var template MQTT_v3_1_1_Message v_pubcomp := m_pubcomp(v_pubrel_packet_id)
              f_send_mqtt(v_conn, v_pubcomp)
              setverdict(pass, "Received PUBREL with correct packet identifier")
            } else {
              f_terminate_due_to_violation(v_received.conn)
              setverdict(fail, "Received PUBREL with incorrect packet identifier")
            }
          }
          [] MQTT_PCO.receive(MQTTasp_Message:?) {
            setverdict(fail, "IUT respond with unexpected message ", v_received)
          }
        }
      }
      [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
        setverdict(fail, "IUT respond with unexpected message ", v_received)
      }
    }

    deactivate(v_connack_default)
  }

  /*
  *
  */
  function f_MQTT_Client_PUBCOMP_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var MQTT_Connection v_conn
    var default v_connack_default := activate(a_mqtt_connack_default())

    // Initial condition: trigger the upper tester to connect and subscribe
    f_ut_initial_connect_01()
    f_ut_subscribe(EXACTLY_ONE_DELIVERY, v_conn)

    if(isbound(v_conn))
    {
      // expected bahaviour
      var octetstring v_payload := '0123456789ABCDEF'O
      var UTF8EncodedString v_topic := f_utf8_from_charstring(PX_PUBLISH_TOPIC)
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(p_qos := EXACTLY_ONE_DELIVERY))
      var integer v_packet_id := 123

      var MQTT_v3_1_1_Publish v_publish := valueof(t_publish_packet(v_pub_header, v_packet_id, v_topic, v_payload))
      var template MQTT_v3_1_1_Message v_message := {msg := { publish := v_publish }}
      var template MQTTasp_Message v_expect := mw_mqtt_message(mw_pubrec_header_flags('0000'B))
      var template MQTTasp_Message v_pubrec := mw_mqtt_message(mw_pubrec)

      f_send_mqtt(v_conn, v_message)
      alt {
        [] MQTT_PCO.receive(v_expect) -> value v_received {
          v_packet_id := v_received.msg.msg.pubrec.packet_identifier
          var template MQTT_v3_1_1_Message v_pubrel := m_pubrel(v_packet_id)
          v_expect := mw_mqtt_message(mw_pubcomp_header_flags('0000'B))
          var template MQTTasp_Message v_pubcomp := mw_mqtt_message(mw_pubcomp)

          f_send_mqtt(v_conn, v_pubrel)
          alt {
            [] MQTT_PCO.receive(v_expect) {
              setverdict(pass, "Checked PUBCOMP header flags")
            }
            [] MQTT_PCO.receive(v_pubcomp) {
              f_terminate_due_to_violation(v_received.conn)
              setverdict(fail, "Received invalid PUBCOMP")
            }
          }
        }
        [] MQTT_PCO.receive(v_pubrec) -> value v_received {
          f_terminate_due_to_violation(v_received.conn)
          setverdict(fail, "Received invalid PUBREC")
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
      }
    } else {
      setverdict(inconc, "IUT did not subscribe")
    }

    deactivate(v_connack_default)
  }
} // group publishGroup

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_SUBSCRIBE_01() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send a SUBSCRIBE"
  var template MQTT_UT_Message v_trigger := m_ut_client_subscribe_01(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_subscribe_valid)) -> value v_received {
      f_send_suback_1(v_received.conn, v_received.msg.msg.subscribe.packet_identifier, 0)
      setverdict(pass, "IUT send SUBSCRIBE with correct header flags")
      break
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_SUBSCRIBE_02() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send a SUBSCRIBE"
  var template MQTT_UT_Message v_trigger := m_ut_client_subscribe_02(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_subscribe_valid)) -> value v_received {
      if(v_received.msg.msg.subscribe.packet_identifier > 0) {
        f_send_suback_1(v_received.conn, v_received.msg.msg.subscribe.packet_identifier, 0)
        setverdict(pass, "IUT send SUBSCRIBE with valid packet identifier")
      } else {
        f_terminate_due_to_violation(v_received.conn)
        setverdict(fail, "SUBSCRIBE must have a non-zero 16-Bit packet identifier")
      }
      break
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_SUBSCRIBE_03() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send a SUBSCRIBE with first ID"
  var template MQTT_UT_Message v_trigger := m_ut_client_subscribe_03(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_subscribe_valid)) -> value v_received {
      var integer v_packet_id_1 := v_received.msg.msg.subscribe.packet_identifier

      timer t_response := PX_WAIT_FOR_RESPONSE_TIMER;
      t_response.start;

      v_free_text := "Please send a SUBSCRIBE with second ID"
      v_trigger := m_ut_client_subscribe_03(v_free_text)
      f_ut_trigger(v_trigger)

      alt {
        [] MQTT_PCO.receive(mw_mqtt_message(mw_subscribe_valid)) -> value v_received {
          var integer v_packet_id_2 := v_received.msg.msg.subscribe.packet_identifier
          if(v_packet_id_1 != v_packet_id_2) {
            f_send_suback_1(v_received.conn, v_packet_id_1, 0)
            f_send_suback_1(v_received.conn, v_packet_id_2, 0)
            setverdict(pass, "IUT assigned an unused packet identifier")
          } else {
            f_terminate_due_to_violation(v_received.conn)
            setverdict(fail, "IUT assigned an used packet identifier")
          }
        }
        [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
          setverdict(fail, "IUT respond with unexpected message ", v_received)
        }
        [] t_response.timeout {
          setverdict(fail, "IUT did not send the second SUBSCRIBE in time")
        }
      }
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_UNSUBSCRIBE_01() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send an UNSUBSCRIBE"
  var template MQTT_UT_Message v_trigger := m_ut_client_unsubscribe_01(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_unsubscribe_valid)) -> value v_received {
      f_send_unsuback(v_received.conn, v_received.msg.msg.unsubscribe.packet_identifier)
      setverdict(pass, "IUT send UNSUBSCRIBE with correct header flags")
      break
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_UNSUBSCRIBE_02() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send an UNSUBSCRIBE"
  var template MQTT_UT_Message v_trigger := m_ut_client_unsubscribe_02(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_unsubscribe_valid)) -> value v_received {
      var UCHAR0_65535 v_topic_filter := v_received.msg.msg.unsubscribe.payload[0].topic_filter
      if(f_is_valid_utf8(f_utf8_from_charstring(v_topic_filter))) {
        f_send_unsuback(v_received.conn, v_received.msg.msg.unsubscribe.packet_identifier)
        setverdict(pass, "Topic filter is valid UTF-8 string")
      } else {
        f_terminate_due_to_violation(v_received.conn)
        setverdict(fail, "Topic filter is invalid UTF-8 string")
      }
      break
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_DISCONNECT_01() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to disconnect
  var charstring v_free_text := "Please send a DISCONNECT"
  var template MQTT_UT_Message v_trigger := m_ut_client_disconnect_01(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  timer t_timeout := PX_MAX_TC_TIMER
  t_timeout.start
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_disconnect_flags)) -> value v_received {
      setverdict(pass, "IUT send DISCONNECT with correct header flags")
      break
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
    }
    [] t_timeout.timeout {
      setverdict(fail, "IUT did not send a DISCONNECT")
      break
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_DISCONNECT_02() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received

  // trigger the upper tester to connect
  f_ut_initial_connect_01()

  // trigger the upper tester to publish with QoS 1
  var charstring v_free_text := "Please send a DISCONNECT"
  var template MQTT_UT_Message v_trigger := m_ut_client_disconnect_02(v_free_text)
  f_ut_trigger(v_trigger)

  // expected behaviour
  timer t_timeout := PX_MAX_TC_TIMER
  t_timeout.start
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_disconnect_flags)) -> value v_received {
      alt {
        [] MQTT_PCO.receive(MQTT_ASP_Event:?) {
          setverdict(pass, "IUT correctly closed TCP connection")
          break
        }
      }
    }
    [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
      setverdict(fail, "IUT respond with unexpected message ", v_received)
      break
    }
    [] t_timeout.timeout {
      setverdict(fail, "IUT did not send a DISCONNECT")
      break
    }
  }
}

/*
* @purpose TODO
*
* @reference TODO
*/
function f_MQTT_Client_FEAT_KEEPALIVE_01() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received
  //var MQTT_Connection v_conn
  //var default v_connack_default := activate(a_mqtt_connack_default())

  // trigger the upper tester
  f_ut_initial_connect_02(PX_KEEP_ALIVE)

  // expected behaviour
  timer t_keep_alive := int2float(PX_KEEP_ALIVE) * 1.5
  t_keep_alive.start
  alt {
    [] MQTT_PCO.receive(mw_mqtt_message(mw_pingreq)) -> value v_received {
      setverdict(pass, "IUT send correctly PINGREQ within keep alive interval")
      f_send_ping_resp(v_received.conn)
      break
    }
    [] t_keep_alive.timeout {
      setverdict(fail, "IUT did not send a PINGREQ within keep alive interval")
      break
    }
  }


  //deactivate(v_connack_default)
}

} // module
