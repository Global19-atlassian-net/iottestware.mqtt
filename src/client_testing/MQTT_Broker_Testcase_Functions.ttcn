/*******************************************************************************
* Copyright (c) 2018 Relayr GmbH
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*   Alexander Kaiser
*   Sascha Hackel
*   Axel Rennoch
*******************************************************************************/
module MQTT_Broker_Testcase_Functions {

import from MQTT_TestSystem_Common all;

// defaults
import from MQTT_Defaults_Common all;
import from MQTT_Defaults_CONNACK all;

// PIXITs
import from MQTT_Broker_Pixits all;

// Functions
import from MQTT_Functions_SetUp all;
import from MQTT_Functions_Conformance all;
import from MQTT_Functions_Protocol all;
import from MQTT_Functions_Network all;
import from MQTTasp_PortType all;

// Types
import from MQTTasp_Types all;
import from MQTT_v3_1_1_Types all;

// Templates
import from MQTT_Templates_MQTTasp all;
import from MQTT_Templates_CONNECT all;
import from MQTT_Templates_PUBLISH all;

import from UTF8_Helper all;

group connectGroup
{
  /*
  * @purpose TODO
  *
  * @reference [MQTT-2.2.2-1]
  */
  function f_MQTT_Client_CONNECT_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    // [UT] upper tester command via logging forwarded to the webserver
    log("[UT](send CONNECT): ", mw_connect_header);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        // [TC_*] logging forwarded to the webserver can enrich resoult
        log("[TC_MQTT_Client_CONNECT_01](received connect): ", v_received.msg.msg.connect_msg)

        if (match(v_received.msg.msg.connect_msg.header, mw_connect_header)) {
          f_send_connack(v_conn)
          setverdict(pass, "Header flags checked")
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Header flags must be set to '0000'B")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-1]
  */
  function f_MQTT_Client_CONNECT_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_protocol_name);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if (f_connect_protocol_name_valid(v_received.msg.msg.connect_msg) or PX_ACCEPT_ANY_PROTOCOL_NAME) {
          f_send_connack(v_conn)

          log("[TC_MQTT_Client_CONNECT_02](received connect): ", v_received.msg.msg.connect_msg)

          // [MQTT-3.1.2-1] allows also to accept any other protocol names: configure PX_ACCEPT_ANY_PROTOCOL_NAME
          if (PX_ACCEPT_ANY_PROTOCOL_NAME) {
            setverdict(pass, "TS Broker accepts any protocol name")
          } else {
            setverdict(pass, "Protocol name checked")
          }
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Protocol name must be UTF-8 encoded 'MQTT'")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-2]
  */
  function f_MQTT_Client_CONNECT_03() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_protocol_level);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_03](received connect): ", v_received.msg.msg.connect_msg)

        if (f_connect_protocol_lvl_valid(v_received.msg.msg.connect_msg)) {
          f_send_connack(v_conn)
          setverdict(pass, "Protocol Level checked")
        } else {
          f_unacceptable_protocol(v_conn)
          setverdict(fail, "Protocol Level for MQTT v3.1.1 must be 4")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-3]
  */
  function f_MQTT_Client_CONNECT_04() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_reserved);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_04](received connect): ", v_received.msg.msg.connect_msg)

        if (f_connect_flags_reserved_valid(v_received.msg.msg.connect_msg.flags)) {
          f_send_connack(v_conn)
          setverdict(pass, "Reserved flag checked")
        } else {
          // close network connection as specified in [MQTT-2.2.2-2]
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Reserved flag must be set to '0'")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-9], [MQTT-3.1.2-14]
  */
  function f_MQTT_Client_CONNECT_05() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_will_flag);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_05](received connect): ", v_received.msg.msg.connect_msg)

        // TODO: check the will flag -> outsource to conformance function
        if (match(v_received.msg, mw_connect_will_flag)) {

          // TODO: outsource to separate conformance function
          var QoS vt_invalid_qos := RESERVED
          if(match(vt_invalid_qos, v_received.msg.msg.connect_msg.flags.will_qos))
          {
            // Note: inverted match -> vt_INVALID_qos
            f_terminate_due_to_violation(v_conn)
            setverdict(fail, "Received CONNECT contains invalid Will Qos")
          } else {
            f_send_connack(v_conn)
            setverdict(pass, "Will flag and Will QoS checked")
          }
        } else {
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Will flag must be set to '1'")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-11], [MQTT-3.1.2-13], [MQTT-3.1.2-15]
  */
  function f_MQTT_Client_CONNECT_06() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_will_flag('0'B));
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_06](received connect): ", v_received.msg.msg.connect_msg)

        if(match(v_received.msg, mw_connect_will_flag)) {

          // check if will_qos is valid
          //TODO: mw_connect_will_flag matching only valid?
          var QoS vt_invalid_qos := AT_MOST_ONCE_DELIVERY
          if(match(vt_invalid_qos, v_received.msg.msg.connect_msg.flags.will_qos)){
            setverdict(fail, "Received CONNECT contains Will Qos > 0")
          }

          // check if will_retain
          //TODO: mw_connect_will_flag matching only valid?
          if(match('1'B, v_received.msg.msg.connect_msg.flags.will_retain)) {
            setverdict(fail, "Received CONNECT contains will_retain but will_flag is '0'B")
          }

          // check if connect payload is empty
          var template MQTT_v3_1_1_ConnectPayload vt_conn_payload := mw_connect_payload_lwt_empty
          if(match(v_received.msg.msg.connect_msg.payload, vt_conn_payload)) {
            setverdict(fail, "Received CONNECT contains LWT payload but will_flag is '0'B")
          }

          if(getverdict == pass) {
            f_send_connack(v_conn)
            setverdict(pass, "Will flag and Will QoS checked")
          } else {
            // close network connection; already failed
            f_terminate_due_to_violation(v_conn)
          }

        } else {
          // close network connection
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "Will flag must be set to '1'")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-18], [MQTT-3.1.2-20], [MQTT-3.1.2-22]
  */
  function f_MQTT_Client_CONNECT_07() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT): ", mw_connect_credentials_empty);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_07](received connect): ", v_received.msg.msg.connect_msg)

        if (match(v_received.msg, mw_connect_credentials_empty)) {
          f_send_connack(v_conn)
          setverdict(pass, "No credentials behaviour checked")
        } else {
          // close network connection
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "not match (usr_flag='0'B : pswd_flag='0'B : payload=omit)")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-19]
  */
  function f_MQTT_Client_CONNECT_08() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    var BIT1n v_user_name_flag := '1'B
    var BIT1n v_password_flag := '0'B
    var template MQTT_v3_1_1_Message vt_conn_msg := mw_connect_credentials_payload(v_user_name_flag, v_password_flag)

    log("[UT](send CONNECT): ", vt_conn_msg);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_08](received connect): ", v_received.msg.msg.connect_msg)

        // TODO: matching omits? see Playground.TCU_Client_CONNECT_08
        if (not ispresent(v_received.msg.msg.connect_msg.payload.user_name))
        {
          setverdict(fail, "No user name in payload")
        }

        if (ispresent(v_received.msg.msg.connect_msg.payload.password))
        {
          setverdict(fail, "pswd flag is '0'B but payload contains pswd")
        }

        if (getverdict == fail)
        {
          // close network connection
          f_terminate_due_to_violation(v_conn)
        } else {
          f_send_connack(v_conn)
          setverdict(pass, "Username set correctly")
        }
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference [MQTT-3.1.2-21]
  */
  function f_MQTT_Client_CONNECT_09() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    var BIT1n v_user_name_flag := '1'B
    var BIT1n v_password_flag := '1'B
    var template MQTT_v3_1_1_Message vt_conn_msg := mw_connect_credentials_payload(v_user_name_flag, v_password_flag)

    log("[UT](send CONNECT): ", vt_conn_msg);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        log("[TC_MQTT_Client_CONNECT_09](received connect): ", v_received.msg.msg.connect_msg)

        if (not ispresent(v_received.msg.msg.connect_msg.payload.user_name))
        {
          setverdict(fail, "uesr_name flag is '1'B but payload dosn't contain user_name")
        }

        if (not ispresent(v_received.msg.msg.connect_msg.payload.password))
        {
          setverdict(fail, "password flag is '1'B but payload dosn't contain a password")
        }

        if (getverdict == fail)
        {
          // close network connection
          f_terminate_due_to_violation(v_conn)
        } else {
          f_send_connack(v_conn)
          setverdict(pass, "Username and Passwort set correctly")
        }
      }
      [] MQTT_PCO.receive {
        log("Received unexpected PDU")
        setverdict(fail, "received unexpected PDU")
      }
    } // alt
  }

  /*
  * @purpose TODO
  * @remark by comparing each field with the sent values, the order is checked implicitly.
  *         Wrong order would silently swap the fields during decoding
  *
  * @reference [MQTT-3.1.3-1]
  */
  function f_MQTT_Client_CONNECT_10() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received

    var UTF8EncodedString v_client_id := f_utf8_from_charstring(PX_CLIENT_ID);
    var UTF8EncodedString v_will_topic := f_utf8_from_charstring(PX_WILL_TOPIC);
    var OctStringWithLength v_will_msg := { stringLength := lengthof(PX_WILL_MESSAGE), stringItem := char2oct(PX_WILL_MESSAGE) };
    var UTF8EncodedString v_user_name := f_utf8_from_charstring(PX_USER_NAME);
    var OctStringWithLength v_password := { stringLength := lengthof(PX_PASSWORD), stringItem := char2oct(PX_PASSWORD) }

    var template MQTT_v3_1_1_Message vt_conn_msg := m_connect_credentials_payload_lwt(v_client_id, v_will_topic, v_will_msg, v_user_name, v_password)
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT with PAYLOAD): ", vt_conn_msg.msg.connect_msg.payload);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);
        f_send_connack(v_conn)

        log("[TC_MQTT_Client_CONNECT_10](received connect): ", v_received.msg.msg.connect_msg)
        setverdict(pass, "Order of fields in CONNECT Payload checked")
      }
      [] MQTT_PCO.receive {
        log("Received unexpected PDU")
        // TODO: f_terminate_due_to_violation(v_conn)  // NOTE: not conformant response!! checking all fields would be still required here!
        setverdict(fail, "received unexpected PDU")
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_CONNECT_11() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT with valid CLIENT_ID): ");
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(ispresent(v_received.msg.msg.connect_msg.payload.client_identifier))
        {
          var UTF8EncodedString v_client_id := v_received.msg.msg.connect_msg.payload.client_identifier
          if(f_client_id_valid(v_client_id))
          {
            f_send_connack(v_conn)
            setverdict(pass, "Client ID ", v_client_id.stringItem, " is valid")
          }
          else
          {
            f_terminate_due_to_violation(v_conn)
            setverdict(fail, "Client ID", v_client_id.stringItem, " is invalid")
          }
        }
        else
        {
          f_terminate_due_to_violation(v_conn)
          setverdict(fail, "No Client ID was given")
        }
      }
      [] MQTT_PCO.receive {
        log("Received unexpected PDU")
        setverdict(fail, "received unexpected PDU")
      }
    } // alt
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_CONNECT_12() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT without CLIENT_ID and Clean Session): ", mdw_connect_msg_clean_session);
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        /*
         * Note:
         * single specific and (probably) not reusable case and therefore not in MQTT_Functions_Conformance.ttcn
         * This way the verdict message is more precise
         */
        log("[MQTT_v4][checked]: {[MQTT-3.1.3-7]}")

        // if(match(v_received.msg, mdw_connect_msg_clean_session)) <- does not match directly!
        if(match(v_received.msg.msg.connect_msg.payload.client_identifier, mdw_connect_msg_clean_session.msg.connect_msg.payload.client_identifier))
        {
          if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_msg_clean_session.msg.connect_msg.flags))
          {
            f_send_connack(v_conn)
            setverdict(pass, "Empty Client ID and Clean Session flag set correctly")
          }
          else
          {
            f_send_connack(v_conn, 2) // [MQTT-3.1.3-9]
            setverdict(fail, "Client ID is empty but Clean Session flag is not set")
          }
        }
        else
        {
          setverdict(fail, "Client ID is not empty")
        }
      }
      [] MQTT_PCO.receive(?) -> value v_received{
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_CONNECT_13() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    log("[UT](send CONNECT with Will flag and a valid Will Topic):");
    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_will_flag))
        {
          if(ispresent(v_received.msg.msg.connect_msg.payload.will_topic))
          {
            var UTF8EncodedString v_will_topic := v_received.msg.msg.connect_msg.payload.will_topic;
            if(f_topic_valid(v_will_topic))
            {
              f_send_connack(v_conn)
              setverdict(pass, "Will Topic is valid UTF-8")
            }
            else
            {
              setverdict(fail, "Will Topic is invalid UTF-8")
            }
          }
          else
          {
            setverdict(fail, "Will Topic is not present")
          }
        }
        else
        {
          setverdict(fail, "Will flag is not set")
        }
      }
      [] MQTT_PCO.receive(?) -> value v_received{
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_CONNECT_14() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

    alt {
      [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
        var MQTT_Connection v_conn := v_received.conn
        f_add_connection(v_conn);

        if(match(v_received.msg.msg.connect_msg.flags, mdw_connect_credentials_username))
        {
          // TODO: decoding of MQTT payload seems to be incorrect!
          if(ispresent(v_received.msg.msg.connect_msg.payload.user_name))
          {
            if(f_username_valid(v_received.msg.msg.connect_msg.payload.user_name))
            {
              f_send_connack(v_conn)
              setverdict(pass, "Username is valid UTF-8")
            }
            else
            {
              setverdict(fail, "Username is invalid UTF-8")
            }
          }
          else
          {
            setverdict(fail, "Username is not present in connect payload")
          }
        }
        else
        {
          setverdict(fail, "Username flag is not set")
        }
      }
      [] MQTT_PCO.receive(?) -> value v_received{
        log("Received unexpected PDU: ", v_received)
        setverdict(fail, "received unexpected PDU")
      }
    }
  }
} // group connectGroup

group publishGroup
{
  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_PUBLISH_01() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)

    log("[UT](send PUBLISH packet with QoS 0):");
    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(AT_MOST_ONCE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          if(match(v_received.msg.msg.publish.header.dup_flag, '0'B))
          {
            setverdict(pass, "received PUBLISH with QoS 0 and DUP 0")
          }
          else
          {
            setverdict(fail, "received PUBLISH has wrong DUP")
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
    }

    deactivate(v_connack_default)
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_PUBLISH_02() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)
    timer t_retransmission := PX_PUB_RETRANSMISSION_TIMER

    log("[UT](send PUBLISH packet with QoS 1):");
    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(AT_LEAST_ONCE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          if(v_received.conn.client_state != Wait_publish)
          {
            // NOTE: drop the first publish packet and set client state to
            // dropping the packet should enforce re-transmission
            f_change_connection_client_state(v_received.conn, Wait_publish)
            t_retransmission.start
            repeat;
          }
          else
          {
            if(match(v_received.msg.msg.publish.header.dup_flag, '1'B))
            {
              f_send_puback(v_received.conn, v_received.msg.msg.publish.packet_identifier)
              setverdict(pass, "received PUBLISH with QoS 1 and DUP 1")
            }
            else
            {
              setverdict(fail, "received PUBLISH has wrong DUP")
            }
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
      [] t_retransmission.timeout {
        setverdict(fail, "no retransmission of PUBLISH with DUP 1")
      }
    }

    deactivate(v_connack_default)
  }

  /*
  * @purpose TODO
  *
  * @reference TODO
  */
  function f_MQTT_Client_PUBLISH_03() runs on MQTT_Broker_MTC
  {
    var MQTTasp_Message v_received
    var default v_connack_default := activate(a_mqtt_connack_default())
    var template MQTTasp_Message vt_publish := mw_mqtt_message(mw_publish_all)
    timer t_retransmission := PX_PUB_RETRANSMISSION_TIMER

    log("[UT](send PUBLISH packet with QoS 2):");
    alt {
      [] MQTT_PCO.receive(vt_publish) -> value v_received {
        var template MQTT_v3_1_1_PublishHeader v_pub_qos := mdw_publish_header_qos(EXACTLY_ONE_DELIVERY)
        if(match(v_received.msg.msg.publish.header, v_pub_qos))
        {
          if(v_received.conn.client_state != Wait_publish)
          {
            // drop the first publish packet and set client state to
            f_change_connection_client_state(v_received.conn, Wait_publish)
            t_retransmission.start
            repeat;
          }
          else
          {
            if(match(v_received.msg.msg.publish.header.dup_flag, '1'B))
            {
              f_send_puback(v_received.conn, v_received.msg.msg.publish.packet_identifier)
              setverdict(pass, "received PUBLISH with QoS 2 and DUP 1")
            }
            else
            {
              setverdict(fail, "received PUBLISH has wrong DUP")
            }
          }
        }
        else
        {
          setverdict(fail, "received PUBLISH has wrong QoS")
        }
      }
      [] t_retransmission.timeout {
        setverdict(fail, "no retransmission of PUBLISH with DUP 1")
      }
    }

    deactivate(v_connack_default)
  }
} // group publishGroup

} // module


/*
* @purpose TODO
*
* @reference TODO
*
function f_MQTT_Client_TEMPLATE() runs on MQTT_Broker_MTC
{
  var MQTTasp_Message v_received
  var template MQTTasp_Message vt_connect_all := mw_mqtt_message(mw_connect);

  alt {
    [] MQTT_PCO.receive(vt_connect_all) -> value v_received {
      var MQTT_Connection v_conn := v_received.conn
      f_add_connection(v_conn);
      // TODO:
    }
    [] MQTT_PCO.receive(?) -> value v_received{
      log("Received unexpected PDU: ", v_received)
      setverdict(fail, "received unexpected PDU")
    }
  }
}*/
