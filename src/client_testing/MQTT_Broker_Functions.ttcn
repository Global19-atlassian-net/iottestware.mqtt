/*******************************************************************************
 * Copyright (c) 2018 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html 
 *
 * Contributors:
 *   Alexander Kaiser
 *    Sascha Hackel
 *******************************************************************************/
module MQTT_Broker_Functions {

import from MQTT_Common_TestSystem all;
import from MQTT_Common_Templates all;
import from MQTT_Templates all;
import from MQTTasp_PortType all;
import from MQTTasp_Types all;
import from MQTTasp_CtrlFunct all;

//import from IPL4asp_PortType all;
import from IPL4asp_Types all;

function f_init_broker_mtc() runs on MQTT_Broker_MTC {
  log("[INIT](Initialize MQTT Broker MTC)")
}

function f_init_broker_ptc() runs on MQTT_Broker_PTC 
return boolean {
  log("[INIT](Initialize MQTT Broker PTC)")
  map(self:MQTT_PCO, system:IPL4_PCO);

  var Result vl_result := MQTTasp_CtrlFunct.f_IPL4_listen(MQTT_PCO, "0.0.0.0", 1883, {tcp := {}})

  if (not(ispresent(vl_result.connId)))
  {
    log("[INIT](Could not connect TCP/TLS)");
    stop;
    return false;
  } 

  // TODO: check result
  ctx.connId := vl_result.connId
  vl_connections := {}
  return true;
}

function f_clear_broker_ptc() runs on MQTT_Broker_PTC {
  log("[CLR](Clear MQTT Broker PTC)")

  // cleanly disconnect all connections
  f_disconnect_all();

  map(self:MQTT_PCO, system:IPL4_PCO);
  self.stop;
}

function f_add_connection(MQTT_Connection p_mqtt_con) runs on MQTT_Broker_PTC {
  var integer v_conn_id := p_mqtt_con.ipl4.id;
  vl_connections[v_conn_id] := p_mqtt_con;
}

function f_disconnect_all() runs on MQTT_Broker_PTC {
  log("[DISCONNECT](Disconnect all active MQTT Connections)")

  for (var integer i := lengthof(vl_connections); i > 0 ; i := i - 1) {
    if (ispresent(vl_connections[i])) {
      f_disconnect_single(i)
    }
  }
}

function f_disconnect_single(integer p_con_idx) runs on MQTT_Broker_PTC {
  if (ispresent(vl_connections[p_con_idx])) {
    var MQTT_Connection v_mqtt_con := vl_connections[p_con_idx]

    if(ispresent(v_mqtt_con.client_state) and v_mqtt_con.client_state != Disconnected) {
      log("[DISCONNECT](Send Disconnect Request): ", v_mqtt_con)
      var template MQTTasp_Message v_disc_req := t_mqtt_message_conn(t_disconnect, v_mqtt_con)
      MQTT_PCO.send(valueof(v_disc_req))

      v_mqtt_con.client_state := Disconnected;
    } else {
      log("[DISCONNECT](Not possible for ", p_con_idx, "): ", v_mqtt_con);
    }

    if(v_mqtt_con.ipl4.tcp_state != Disconnected) {
      log("c ", v_mqtt_con);
      f_IPL4_close(MQTT_PCO, v_mqtt_con.ipl4.id);
      v_mqtt_con.ipl4.tcp_state := Disconnected;
    }

    vl_connections[p_con_idx] := v_mqtt_con;

  } else {
    log("[DISCONNECT](Requested Connection with idx := ", p_con_idx, " does not exist)")
  }

}

} // module
