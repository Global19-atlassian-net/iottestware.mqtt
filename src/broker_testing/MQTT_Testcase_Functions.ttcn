/*******************************************************************************
* Copyright (c) 2018 Relayr GmbH
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*   Alexander Kaiser
*   Sascha Kretzschmann
*******************************************************************************/
module MQTT_Testcase_Functions {


import from MQTT_TestSystem all;
import from MQTT_TypesAndValues all;
import from MQTT_Functions all;
import from MQTT_Templates all;

import from MQTT_v3_1_1_Types all;

group connectFunctionsGroup
{
      function f_TC_MQTT_BROKER_CONNECT_001() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_flags(p_client_id := v_clientId, p_flags := '1111'B);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_002() runs on MQTT_Client
      {
        const UCHAR0_65535 c_protocolName := "TTQM";
        var UTF8EncodedString v_clientId := f_getClientId();

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_protocol_name(v_clientId, c_protocolName);
        f_send(valueof(v_conMsg));

        var IPL4_Response v_response := f_receive();
        var template IPL4_Response v_connack := { receivedMsg :=  tw_connack };

        if(f_checkNetworkClosedEvent(v_response))
        {
          setverdict(pass, "IUT does not accept incorrect Protocol Names");
        }
        else if(match(v_response, v_connack))
        {
          setverdict(pass, "IUT accepts incorrect Protocol Names");
          f_disconnectMqtt();
        }
        else
        {
          setverdict(fail, v_response);
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_003() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_credentials(v_clientId, v_username, v_password);
        f_send(valueof(v_conMsg));

        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();

        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }

        f_disconnectMqtt();
      }

      function f_TC_MQTT_BROKER_CONNECT_004() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();

        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_reserved;
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_empty(v_clientId);
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_005() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag);

        // TODO: t_connect_payload_credentials contains will_topic := omit -> check if sufficient or empty topic is required here {stringLength := 0, stringItem := ""}
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_credentials(v_clientId, v_username, v_password);

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_006() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '1'B;
        const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };

        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_007() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos := AT_LEAST_ONCE_DELIVERY;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_008() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  RESERVED;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };

        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_009() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };

        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();

        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }

        f_disconnectMqtt();
      }

      function f_TC_MQTT_BROKER_CONNECT_010() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '1'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_011() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();

        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }

        f_disconnectMqtt();
      }

      function f_TC_MQTT_BROKER_CONNECT_012() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '1'B;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_013() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '0'B;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();

        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag);
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_username(v_clientId, v_username);

        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_014() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '0'B;

        var UTF8EncodedString v_clientId := f_getClientId();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_empty(v_clientId));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_015() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '0'B;

        var UTF8EncodedString v_clientId := f_getClientId();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_password(v_clientId, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_016() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_username(v_clientId, v_username));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_017() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;

        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var UTF8EncodedString v_clientId := { stringLength := 24, stringItem := "01234567abcdefghABCDEFGH" };

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        // TODO: only pass verdicts?
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT accepts only clientIds up to 23 Bytes");
        }
        else
        {
          setverdict(pass, "IUT accepts clientIds longer than 23 Bytes");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_018() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;

        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var UTF8EncodedString v_clientId := { stringLength := 23, stringItem := "<([^°+-_!§$%&/=?ß@üäö.," };

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        // TODO: only pass verdicts?
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT does not accept clientIds with special characters");
        }
        else
        {
          setverdict(pass, "IUT accepts clientIds with special characters");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_019() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;

        const UTF8EncodedString c_zero_byte_clientid := {stringLength := 0, stringItem := ""};
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(c_zero_byte_clientid, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();

        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else if(f_checkNetworkClosedEvent(v_response))
        {
          setverdict(pass, "IUT does not allow a client to supply a client identifier that has a length of zero bytes")
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }

        f_disconnectMqtt();
      }

      function f_TC_MQTT_BROKER_CONNECT_020() runs on MQTT_Client
      {
        // Note: No BOM required/specified by the spec.
        //const octetstring c_utf8_bom := 'EFBBBF'O;
        const octetstring c_oCId := 'EDA080'O; // UTF-8 for U+D800
        const UCHAR0_65535 c_ucId := oct2unichar(c_oCId);
        var UTF8EncodedString v_invalid_clientId := f_getClientId();
        v_invalid_clientId.stringItem := v_invalid_clientId.stringItem & c_ucId;

        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_invalid_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          f_disconnectMqtt();
          setverdict(fail, "IUT MUST close the Network Connection");
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_021() runs on MQTT_Client
      {
        const octetstring c_oCId := '00'O; // UTF-8 for U+0000
        const UCHAR0_65535 c_ucId := oct2unichar(c_oCId);
        var UTF8EncodedString v_invalid_clientId := f_getClientId();
        v_invalid_clientId.stringItem := v_invalid_clientId.stringItem & c_ucId;

        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);

        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_invalid_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_022() runs on MQTT_Client
      {
        const BIT1n c_wr := '0'B;                     // Will Retain Flag
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;     // Will QoS
        const BIT1n c_wf := '1'B;                     // Will Flag

        const universal charstring c_wm := "Will Message";
        const octetstring c_os_wm := unichar2oct(c_wm);
        const OctStringWithLength c_willMsg := { stringLength := lengthof(c_os_wm), stringItem := c_os_wm };

        const octetstring c_oWT := 'EDA080'O; // UTF-8 for U+D800
        const UCHAR0_65535 c_ucWT := oct2unichar(c_oWT);
        var UTF8EncodedString v_willTopic := f_getBaseTopicName();
        v_willTopic.stringItem := v_willTopic.stringItem & c_ucWT;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_wr, p_will_qos := c_qos, p_will_flag := c_wf));

        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_willTopic, c_willMsg));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_023() runs on MQTT_Client
      {
        const BIT1n c_wr := '0'B;                     // Will Retain Flag
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;     // Will QoS
        const BIT1n c_wf := '1'B;                     // Will Flag

        const universal charstring c_wm := "Will Message";
        const octetstring c_os_wm := unichar2oct(c_wm);
        const OctStringWithLength c_willMsg := { stringLength := lengthof(c_os_wm), stringItem := c_os_wm};

        const octetstring c_oWT := '00'O; // UTF-8 for U+0000
        const UCHAR0_65535 c_ucWT := oct2unichar(c_oWT);
        var UTF8EncodedString v_willTopic := f_getBaseTopicName();
        v_willTopic.stringItem := v_willTopic.stringItem & c_ucWT;

        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_wr, p_will_qos := c_qos, p_will_flag := c_wf));

        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_willTopic, c_willMsg));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_024() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();

        const octetstring c_oUN := 'EDA080'O; // UTF-8 for U+D800
        const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN);
        var UTF8EncodedString v_username := f_getUsername();
        v_username.stringItem := v_username.stringItem & c_ucUN;

        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);

        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }

      function f_TC_MQTT_BROKER_CONNECT_025() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();

        const octetstring c_oUN := '00'O; // UTF-8 for U+0000
        const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN);
        var UTF8EncodedString v_username := f_getUsername();
        v_username.stringItem := v_username.stringItem & c_ucUN;

        var OctStringWithLength v_password := f_getPassword();

        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);

        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));

        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
} // connectFunctionsGroup

group connackFunctionsGroup
{
    function f_TC_MQTT_BROKER_CONNACK_001() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username, v_password));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_002() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username, v_password));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT accepted connection with clean session set to 1");
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_003() runs on MQTT_Client
    {
      /* Initial Condition */
      f_connectMqtt(p_cleanSession := '0'B);
      f_disconnectMqtt();

      /* Test Purpose */
      f_ipl4_connect_sut();

      const BIT1n c_cleanSession := '0'B;
      const BIT1n c_sessionPresent := '1'B;
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(v_clientId, v_username, v_password, c_cleanSession));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack(c_sessionPresent) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT restored present session");

        // disconnect MQTT Session
        f_disconnectMqtt();
      }
      else if(f_checkNetworkClosedEvent(v_response))
      {
        setverdict(fail, "IUT does not restore present sessions and rejects such sessions")
      }
      else
      {
        // figure out the reason of the wrong response
        if(ispresent(v_response.receivedMsg.msg.connack))
        {
          if(v_response.receivedMsg.msg.connack.session_present_flag != c_sessionPresent)
          {
            setverdict(fail, "IUT does not restore present sessions")
          }
          else
          {
            setverdict(fail, "IUT answered incorrectly with ", v_response.receivedMsg.msg.connack);
          }
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
        f_disconnectMqtt();
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_004() runs on MQTT_Client
    {
      /* Initial Condition */
      f_connectMqtt(p_cleanSession := '1'B);
      f_disconnectMqtt();

      /* Test Purpose */
      f_ipl4_connect_sut();

      const BIT1n c_cleanSession := '0'B;
      const BIT1n c_sessionPresent := '0'B;
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(v_clientId, v_username, v_password, c_cleanSession));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack(c_sessionPresent) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT had no present session to restore");

        // disconnect MQTT Session
        f_disconnectMqtt();
      }
      else if(f_checkNetworkClosedEvent(v_response))
      {
        setverdict(fail, "IUT rejects connections with CleanSession Flag set to 0")
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_005() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      const integer c_protoLevel := 255;
      var template MQTT_v3_1_1_Message v_conMsg := t_connect_protocol_level(v_clientId, v_username, v_password, c_protoLevel);
      f_send(valueof(v_conMsg));

      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_unacceptable_version };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and Return Code 0x01");

        // wait for Network Disconnect
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after ACK and Return Code 0x01");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after ACK and Return Code 0x01");
          f_disconnectMqtt();
        }
      }
      else
      {
        if(ispresent(v_response.timeoutEvent))
        {
          setverdict(fail, "IUT timed out after ", v_response.timeoutEvent, "s without any response")
        }
        else if(f_checkNetworkClosedEvent(v_response))
        {
          setverdict(fail, "IUT closed the connection without preceding ACK with Return Code 0x01")
        }
        else
        {
          setverdict(fail, "IUT send wrong response ", v_response);
          f_disconnectMqtt();
        }
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_006() runs on MQTT_Client
    {
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();

      const BIT1n c_clean_session := '0'B;
      const UTF8EncodedString c_zero_byte_clientid := {stringLength := 0, stringItem := ""};

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(c_zero_byte_clientid, v_username, v_password, c_clean_session));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0x02
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_id_rejected };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and return code 0x02");

        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after refusing connection");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        if(ispresent(v_response.timeoutEvent))
        {
          setverdict(fail, "IUT timed out after ", v_response.timeoutEvent, "s without any response")
        }
        else if(f_checkNetworkClosedEvent(v_response))
        {
          setverdict(fail, "IUT closed the connection without preceding ACK with Return Code 0x02")
        }
        else
        {
          setverdict(fail, "IUT must reject the client ID with ACK and Return Code 0x02");
          f_disconnectMqtt();
        }
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_007() runs on MQTT_Client
    {
      // build malformed username
      // Note: password is an octetstring and can't be malformed
      const octetstring c_oD800 := 'EDA080'O; // UTF-8 for U+D800
      const UCHAR0_65535 c_ucD800 := oct2unichar(c_oD800);

      var UTF8EncodedString v_username_utf8 := f_getUsername();
      var universal charstring v_username := v_username_utf8.stringItem
      var UTF8EncodedString v_username_malformed := { stringLength := lengthof(v_username & c_ucD800), stringItem := (v_username & c_ucD800) };

      var UTF8EncodedString v_clientId := f_getClientId();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username_malformed, v_password));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0x04
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_malformed_username };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after CONNACK(rc=0x04)");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        v_expected := { receivedMsg :=  tw_connack };
        if(match(v_response, v_expected))
        {
          // Note: Broker might not require credentials. However, username is malformed and thus MUST be rejected
          setverdict(fail, "IUT does not check credentials");
          f_disconnectMqtt();
        }
        else if(match(v_response, t_connection_closed))
        {
          setverdict(fail, "IUT closed connection without CONNACK(rc=0x04)")
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
          f_disconnectMqtt();
        }
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_008() runs on MQTT_Client
    {
      // build invalid username
      const UCHAR0_65535 c_postfix := "_invalid";

      var UTF8EncodedString v_username_utf8 := f_getUsername();
      var universal charstring v_username := v_username_utf8.stringItem
      var UTF8EncodedString v_username_invalid := { stringLength := lengthof(v_username & c_postfix), stringItem := (v_username & c_postfix) };

      var UTF8EncodedString v_clientId := f_getClientId();
      var OctStringWithLength v_password := f_getPassword();

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username_invalid, v_password));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0x05
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_not_authorized };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after CONNACK(rc=0x05)");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        v_expected := { receivedMsg :=  tw_connack };
        if(match(v_response, v_expected))
        {
          // Note: Broker might not require credentials.
          setverdict(inconc, "IUT does not require credentials");
          f_disconnectMqtt();
        }
        else if(match(v_response, t_connection_closed))
        {
          setverdict(fail, "IUT closed connection without CONNACK(rc=0x05)")
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
          f_disconnectMqtt();
        }
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_009() runs on MQTT_Client
    {
      // build invalid password
      const OCT0_65535 c_postfix := unichar2oct("_invalid");

      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();

      var OctStringWithLength v_password_valid := f_getPassword();
      var OCT0_65535 v_password := v_password_valid.stringItem;
      var OctStringWithLength v_password_invalid := { stringLength := lengthof(v_password & c_postfix), stringItem := (v_password & c_postfix) };

      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username, v_password_invalid));
      f_send(v_conMsg);

      // wait for CONNACK with return_code := 0x05
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_not_authorized };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after CONNACK(rc=0x05)");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        v_expected := { receivedMsg :=  tw_connack };
        if(match(v_response, v_expected))
        {
          // Note: Broker might not require credentials.
          setverdict(inconc, "IUT does not require credentials");
          f_disconnectMqtt();
        }
        else if(match(v_response, t_connection_closed))
        {
          setverdict(fail, "IUT closed connection without CONNACK(rc=0x05)")
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
          f_disconnectMqtt();
        }
      }
    }

    function f_TC_MQTT_BROKER_CONNACK_010() runs on MQTT_Client
    {
      setverdict(inconc, "unable to test CONNACK return_code=0x03")
    }
} // connackFunctionsGroup

group publishFunctionsGroup
{
  function f_TC_MQTT_BROKER_PUBLISH_001() runs on MQTT_Client
  {
    f_connectMqtt();

    var integer v_pid := f_randomPacketId();  // Note: encoder will filter v_pid out anyways [MQTT-2.3.1-1]
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
    var octetstring v_payload := 'A0A0'O;
    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('1'B, AT_MOST_ONCE_DELIVERY))
    var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

    f_send(v_publish)

    if(f_receiveNetworkClosedEvent())
    {
      setverdict(pass, "IUT closed the Network Connection correctly");
    }
    else
    {
      setverdict(fail, "IUT MUST close the Network Connection");
      f_disconnectMqtt();
    }
  }


  function f_TC_MQTT_BROKER_PUBLISH_002() runs on MQTT_Client
  {
    f_connectMqtt();

    var integer v_pid := f_randomPacketId();
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
    var octetstring v_payload := 'A0A0'O;
    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('0'B, RESERVED))
    var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

    f_send(v_publish)

    if(f_receiveNetworkClosedEvent())
    {
      setverdict(pass, "IUT closed the Network Connection correctly");
    }
    else
    {
      setverdict(fail, "IUT MUST close the Network Connection");
      f_disconnectMqtt();
    }
  }

  function f_TC_MQTT_BROKER_PUBLISH_003() runs on MQTT_Client
  {
    const octetstring c_oUN := 'EDA080'O; // UTF-8 for U+D800
    const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN);

    // TODO: move f_connectMqtt to MQTT_TestCases?
    // TODO: return of f_connectMqtt must be always checked!!
    if(f_connectMqtt())
    {
      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName(c_ucUN);
      var octetstring v_payload := 'A0A0'O;
      var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('0'B, AT_MOST_ONCE_DELIVERY))
      var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

      f_send(v_publish)

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }
    else
    {
      setverdict(fail, "IUT didn't accept connection")
    }
  }

  function f_TC_MQTT_BROKER_PUBLISH_004() runs on MQTT_Client
  {
    f_connectMqtt();

    var integer v_pid := f_randomPacketId();
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("#");
    var octetstring v_payload := 'A0A0'O;
    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('0'B, AT_MOST_ONCE_DELIVERY))
    var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

    f_send(v_publish)

    if(f_receiveNetworkClosedEvent())
    {
      setverdict(pass, "IUT closed the Network Connection correctly");
    }
    else
    {
      setverdict(fail, "IUT MUST close the Network Connection");
      f_disconnectMqtt();
    }
  }

  function f_TC_MQTT_BROKER_PUBLISH_005() runs on MQTT_Client
  {
    f_connectMqtt();

    var integer v_pid := 0;
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("/data");
    var octetstring v_payload := 'A0A0'O;
    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('0'B, AT_LEAST_ONCE_DELIVERY))
    var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

    f_send(v_publish)

    if(f_receiveNetworkClosedEvent())
    {
      setverdict(pass, "IUT closed the Network Connection correctly");
    }
    else
    {
      setverdict(fail, "IUT MUST close the Network Connection");
      f_disconnectMqtt();
    }
  }

  function f_TC_MQTT_BROKER_PUBLISH_006() runs on MQTT_Client
  {
    f_connectMqtt();

    var integer v_pid := 0;
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("/data");
    var octetstring v_payload := 'A0A0'O;
    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader('0'B, EXACTLY_ONE_DELIVERY))
    var MQTT_v3_1_1_Message v_publish := valueof(t_publish(v_pub_header, v_topic.stringItem, v_pid, v_payload))

    f_send(v_publish)

    if(f_receiveNetworkClosedEvent())
    {
      setverdict(pass, "IUT closed the Network Connection correctly");
    }
    else
    {
      setverdict(fail, "IUT MUST close the Network Connection");
      f_disconnectMqtt();
    }
  }
} // publishFunctionsGroup

group subscribeFunctionsGroup
{
     function f_TC_MQTT_BROKER_SUBSCRIBE_001() runs on MQTT_Client
     {
        f_connectMqtt();

        var integer v_pid := f_randomPacketId();
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;
        const BIT4n c_header_flags := '1101'B;

        var UTF8EncodedString v_topic := f_getConcatenatedTopicName("/data");

        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_header_flags := c_header_flags, p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
        f_send(v_subscribe);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_002() runs on MQTT_Client
     {
       f_connectMqtt();

       var integer v_pid := 0;
       const QoS c_qos := AT_MOST_ONCE_DELIVERY;
       const BIT4n c_header_flags := '0010'B;

       var UTF8EncodedString v_topic := f_getConcatenatedTopicName("/data");

       var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_header_flags := c_header_flags, p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
       f_send(v_subscribe);

       if(f_receiveNetworkClosedEvent())
       {
         setverdict(pass, "IUT closed the Network Connection correctly");
       }
       else
       {
         setverdict(fail, "IUT MUST close the Network Connection");
         f_disconnectMqtt();
       }
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_003() runs on MQTT_Client
     {
       f_connectMqtt();

       const octetstring c_oUN := 'EDA080'O; // UTF-8 for U+D800
       const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN);

       var integer v_pid := 0;
       const QoS c_qos := AT_MOST_ONCE_DELIVERY;
       const BIT4n c_header_flags := '0010'B;

       var UTF8EncodedString v_topic := f_getConcatenatedTopicName(c_ucUN);

       var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_header_flags := c_header_flags, p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
       f_send(v_subscribe);

       if(f_receiveNetworkClosedEvent())
       {
         setverdict(pass, "IUT closed the Network Connection correctly");
       }
       else
       {
         setverdict(fail, "IUT MUST close the Network Connection");
         f_disconnectMqtt();
       }
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_004() runs on MQTT_Client
     {
       f_connectMqtt();

       const octetstring c_oUN := '00'O; // UTF-8 for U+0000
       const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN);

       var integer v_pid := 0;
       const QoS c_qos := AT_MOST_ONCE_DELIVERY;
       const BIT4n c_header_flags := '0010'B;

       var UTF8EncodedString v_topic := f_getConcatenatedTopicName(c_ucUN);

       var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_header_flags := c_header_flags, p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
       f_send(v_subscribe);

       if(f_receiveNetworkClosedEvent())
       {
         setverdict(pass, "IUT closed the Network Connection correctly");
       }
       else
       {
         setverdict(fail, "IUT MUST close the Network Connection");
         f_disconnectMqtt();
       }
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_005() runs on MQTT_Client
     {
        f_connectMqtt();

        var integer v_pid := f_randomPacketId();

        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_empty_payload(p_packet_id := v_pid));
        f_send(v_subscribe);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_006() runs on MQTT_Client
     {
       f_connectMqtt();

       var integer v_pid := f_randomPacketId();

       const QoS c_qos := AT_MOST_ONCE_DELIVERY;
       var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

       // Note: 6 leading bits before requested_qos are not available via MQTT_v3_1_1_Types
       @update(t_subscribe_topic) with
       {
         // Note: Figure 3.22 – SUBSCRIBE Packet payload format:
         // Value is flipped here
         // '00'B -> AT_MOST_ONCE_DELIVERY & '111111'B -> reserved flags
         // on wire: -> '11111100'B
         erroneous(msg.subscribe.payload[0].requested_qos) "value(raw) := '00111111'B";
       }

       var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
       f_send_negtest(v_subscribe);

       if(f_receiveNetworkClosedEvent())
       {
         setverdict(pass, "IUT closed the Network Connection correctly");
       }
       else
       {
         setverdict(fail, "IUT MUST close the Network Connection");
         f_disconnectMqtt();
       }

       // clear codec manipulation
       @update(t_subscribe_topic)
     }

     function f_TC_MQTT_BROKER_SUBSCRIBE_007() runs on MQTT_Client
     {
        f_connectMqtt();

        var integer v_pid := f_randomPacketId();
        const QoS c_qos := RESERVED;
        var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
        f_send(v_subscribe);

        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }
} // subscribeFunctionsGroup

group subackFunctionsGroup
{
    function f_TC_MQTT_BROKER_SUBACK_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      var template IPL4_Response v_expected := { receivedMsg := tw_suback_header_flags };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and correct header flags");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_SUBACK_002() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      var template IPL4_Response v_expected := { receivedMsg := tw_suback_packet_id(v_pid) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and correct packet_identifier ", v_pid);
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_SUBACK_003() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_MOST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      // wait for SUBACK with return_code := 0x00
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_SUBACK_004() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      // wait for SUBACK with return_code := 0x01
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          // response was a SUBACK, check the payload
          if(sizeof(v_response.receivedMsg.msg.suback.payload) == 1)
          {
            var integer v_rc := v_response.receivedMsg.msg.suback.payload.return_code[0];
            if(v_rc > c_return_code)
            {
              setverdict(fail, "SUBACK return code ", v_rc, " is greater than requested ");
            }
            else
            {
              // NOTE: SUBACK returns the maximum granted QoS not the requested!
              var QoS v_qos_granted;
              int2enum(v_rc, v_qos_granted);
              setverdict(pass, "IUT granted QoS ", v_qos_granted, " although ", c_qos, " was requested");
            }
          }
          else
          {
            // response SUBACK has more return codes than subscriptions
            setverdict(fail, "SUBACK contains more return codes than subscriptions");
          }
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_SUBACK_005() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := EXACTLY_ONE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      // wait for SUBACK with return_code := 0x02
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          // response was a SUBACK, check the payload
          if(sizeof(v_response.receivedMsg.msg.suback.payload) == 1)
          {
            var integer v_rc := v_response.receivedMsg.msg.suback.payload.return_code[0];
            if(v_rc > c_return_code)
            {
              setverdict(fail, "SUBACK return code ", v_rc, " is greater than requested ");
            }
            else
            {
              // NOTE: SUBACK returns the maximum granted QoS not the requested!
              var QoS v_qos_granted;
              int2enum(v_rc, v_qos_granted);
              setverdict(pass, "IUT granted QoS ", v_qos_granted, " although ", c_qos, " was requested");
            }
          }
          else
          {
            // response SUBACK has more return codes than subscriptions
            setverdict(fail, "SUBACK contains more return codes than subscriptions");
          }
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_SUBACK_006() runs on MQTT_Client
    {
      f_connectMqtt();

      const charstring c_topicPrefix := "/prefix";

      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_MOST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      // this should ensure that the subscription goes to a valid but not accessable topic
      v_topic.stringItem := c_topicPrefix & v_topic.stringItem;
      v_topic.stringLength := v_topic.stringLength + lengthof(c_topicPrefix);

      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);

      // wait for SUBACK with return_code := 0x80
      const integer c_return_code := hex2int('80'H);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          setverdict(inconc, "IUT seems not to implement Access restrictions for subscriptions");
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered not with SUBACK ", v_response);
        }
      }

      f_disconnectMqtt();
    }
}  // subackFunctionsGroup

group unsubscribeFunctionsGroup
{
    function f_TC_MQTT_BROKER_UNSUBSCRIBE_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic('1101'B, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        f_disconnectMqtt();
        setverdict(fail, "IUT MUST close the Network Connection");
      }
    }

    function f_TC_MQTT_BROKER_UNSUBSCRIBE_002() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := 0;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);

      var IPL4_Response v_response := f_receive();
      var template MQTT_v3_1_1_Message v_expected_unsuback :=  tw_unsuback_packed_id(v_pid);

      // The standard references in section 3.10.2 to section 2.3.1 which is not applicable to UNSUBSCRIBE because UNSUBSCRIBE has no QoS
      if(ischosen(v_response.aspEvent))
      {
        setverdict(pass, "IUT closed the Network Connection");
      }
      else if(match(v_response.receivedMsg, v_expected_unsuback))
      {
        setverdict(pass, "IUT answered correctly with UNSUBACK");
        f_disconnectMqtt();
      }
      else
      {
        f_disconnectMqtt();
        setverdict(inconc, "IUT answered with ", v_response);
      }
    }

    function f_TC_MQTT_BROKER_UNSUBSCRIBE_003() runs on MQTT_Client
    {
      f_connectMqtt();

      const octetstring c_oUN := 'EDA080'O; // UTF-8 for U+D800
      const UCHAR0_65535 c_ucUN := oct2unichar(c_oUN) & "/data";

      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName(c_ucUN);

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        f_disconnectMqtt();
        setverdict(fail, "IUT MUST close the Network Connection");
      }
    }

    function f_TC_MQTT_BROKER_UNSUBSCRIBE_004() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_emtpy_topic(v_pid));
      f_send(v_unsubscribe);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        f_disconnectMqtt();
        setverdict(fail, "IUT MUST close the Network Connection");
      }
    }
} // unsubscribeFunctionsGroup

group unsubackFunctionsGroup
{
    function f_TC_MQTT_BROKER_UNSUBACK_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);

      var template IPL4_Response v_expected := { receivedMsg := tw_unsuback_header_flags };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with UNSUBACK and correct header flags");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }

    function f_TC_MQTT_BROKER_UNSUBACK_002() runs on MQTT_Client
    {
      f_connectMqtt();

      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");

      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);

      var template IPL4_Response v_expected := { receivedMsg := tw_unsuback_packed_id(v_pid) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with UNSUBACK and correct packet identifier");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }
} // unsubackFunctionsGroup

group pingreqFunctionsGroup
{
    function f_TC_MQTT_BROKER_PINGREQ_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var MQTT_v3_1_1_Message v_pingReq := valueof(t_ping_req('1111'B));
      f_send(v_pingReq);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }
} // pingreqFunctionsGroup

group pingrespFunctionsGroup
{
    function f_TC_MQTT_BROKER_PINGRESP_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var MQTT_v3_1_1_Message v_pingReq := valueof(t_ping_req('0000'B));
      f_send(v_pingReq);

      var template IPL4_Response v_expected := { receivedMsg := tw_ping_resp('0000'B) };
      var IPL4_Response v_response := f_receive();

      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly to PINGREQ with PINGRESP");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }

      f_disconnectMqtt();
    }
} // pingrespFunctionsGroup

group disconnectFunctionsGroup
{
    function f_TC_MQTT_BROKER_DISCONNECT_001() runs on MQTT_Client
    {
      f_connectMqtt();

      var MQTT_v3_1_1_Message v_disconnect := valueof(t_disconnect('0000'B));
      f_send(v_disconnect);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        // Note: this case should/will never occure!
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }

    function f_TC_MQTT_BROKER_DISCONNECT_002() runs on MQTT_Client
    {
      f_connectMqtt();

      var MQTT_v3_1_1_Message v_disconnect := valueof(t_disconnect('1111'B));
      f_send(v_disconnect);

      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        // Note: this case should/will never occure!
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }
} // disconnectFunctionsGroup

group protocolFeaturesFunctionsGroup
{
  function f_TC_MQTT_BROKER_FEAT_RTND_001() runs on MQTT_Client
  {
    var UTF8EncodedString v_topic := f_getConcatenatedTopicName("retain");
    var octetstring v_payload := 'A0A0'O;

    f_connectMqtt();

    var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publishHeader(-, AT_MOST_ONCE_DELIVERY, '1'B))
    var MQTT_v3_1_1_Message v_pub_send := valueof(t_publish_qos0(v_pub_header, v_topic.stringItem, v_payload))
    f_send(v_pub_send)

    var template MQTT_v3_1_1_Message v_expected := tw_publish_receive_qos0(tw_publishHeader_retained, v_topic.stringItem, v_payload)

    var boolean v_subscribed := f_subscribe(v_topic.stringItem, AT_MOST_ONCE_DELIVERY)

    if(v_subscribed)
    {
      var IPL4_Response v_response := f_receive();

      if(match(v_response.receivedMsg.msg.publish.header, v_expected.msg.publish.header))
      {
        if(match(v_response.receivedMsg.msg.publish.topic_name, v_expected.msg.publish.topic_name))
        {
          if(match(v_response.receivedMsg.msg.publish.payload, v_expected.msg.publish.payload))
          {
            setverdict(pass, "Received retained message")
          }
          else
          {
            setverdict(fail, "PUBLISH payload does not match")
          }
        }
        else
        {
          setverdict(fail, "PUBLISH topic does not match")
        }
      }
      else
      {
        setverdict(fail, "PUBLISH header does not match")
      }
    }
    else
    {
      setverdict(fail, "Failed to subscribe")
    }

    f_disconnectMqtt();
  }
} // protocolFeaturesFunctionsGroup

} // MQTT_Testcase_Functions
