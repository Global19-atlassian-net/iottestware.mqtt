/*******************************************************************************
 * Copyright (c) 2019 Relayr GmbH
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Alexander Kaiser
 *   Sascha Hackel
 *   Axel Rennoch
 *******************************************************************************/
 module MQTT_Client_Behaviors
 {
   import from MQTT_v3_1_1_Types all;
   import from MQTTasp_Types all;

   import from MQTT_Pixits all;
   import from MQTT_TestSystem_Common all;
   import from MQTT_Functions_SetUp all;
   import from MQTT_Functions_Network all;
   import from MQTT_Functions_Protocol all;
   import from MQTT_Functions_Conformance all;

   import from MQTT_Templates_MQTTasp all;
   import from MQTT_Templates_CONNECT all;
   import from MQTT_Templates_CONNACK all;
   import from MQTT_Templates_PUBLISH all;
   import from MQTT_Templates_PUBACK all;
   import from MQTT_Templates_PUBREC all;
   import from MQTT_Templates_PUBREL all;
   import from MQTT_Templates_PUBCOMP all;
   import from MQTT_Templates_SUBSCRIBE all;
   import from MQTT_Templates_SUBACK all;

   import from UTF8_Helper all;
   import from Random_Helper all;

   /*
    * @desc f_mqtt_connect_01 sends a most basic MQTT Connect message with credentials from MQTT_Client_MTC
    * TODO: refactor f_mqtt_connect_[] functions
    * TODO: move to MQTT_Functions_Protocol (??)
    */
   function f_mqtt_connect_valid(integer p_return_code := 0) runs on MQTT_Client_MTC
   {
     // establish TCP connection
     if(f_ipl4_connect())
     {
       var UTF8EncodedString v_client_id := f_utf8_from_charstring(credentials.clientId)
       var UTF8EncodedString v_username := f_utf8_from_charstring(credentials.username)
       var OctStringWithLength v_password := f_octstring_from_charstring(credentials.password)

       var template MQTT_v3_1_1_ConnectFlags v_connect_flags := md_connect_credentials
       var template MQTT_v3_1_1_ConnectPayload v_connect_payload := m_connect_payload_credentials(v_client_id, v_username, v_password)
       var template MQTT_v3_1_1_Message v_connect_packet := m_connect_message_base_02(v_connect_flags, v_connect_payload)
       var template MQTTasp_Message vt_connect := m_mqtt_message_conn(v_connect_packet, connection)
       var MQTTasp_Message v_response

       MQTT_PCO.send(valueof(vt_connect))

       var template MQTTasp_Message v_receive := mw_mqtt_message(mw_connack_rc(p_return_code))
       timer t_timeout := PX_MAX_RESPONSE_TIME;
       t_timeout.start
       alt {
         [] MQTT_PCO.receive(v_receive) {
           connection.client_state := Connected
           break;
         }
         [] MQTT_PCO.receive(mw_mqtt_message(mw_connack)) -> value v_response {
           setverdict(fail, "CONNACK returned unexpected code: ", p_return_code, " != ", v_response.msg.msg.connack.connect_return_code)
           break
         }
         [] t_timeout.timeout {
           setverdict(fail, "No CONNACK received")
           break;
         }
       }
     }
     else
     {
       setverdict(fail, "Client could not connect to ", PX_SUT_HOSTNAME, ":", PX_SUT_PORT)
     }
   }

   /*
    * @desc connect MQTT client with a given keep_alive time
    * TODO: refactor f_mqtt_connect_[] functions
    */
   function f_mqtt_connect_02(integer p_keep_alive, integer p_return_code := 0) runs on MQTT_Client_MTC
   {
     // establish TCP connection
     if(f_ipl4_connect())
     {
       var UTF8EncodedString v_client_id := f_utf8_from_charstring(credentials.clientId)
       var template MQTT_v3_1_1_Message v_connect_packet := md_connect_message_keep_alive(v_client_id, p_keep_alive)
       var template MQTTasp_Message vt_connect := m_mqtt_message_conn(v_connect_packet, connection);

       MQTT_PCO.send(valueof(vt_connect))

       var template MQTTasp_Message v_receive := mw_mqtt_message(mw_connack_rc(p_return_code))
       timer t_timeout := PX_MAX_RESPONSE_TIME;
       t_timeout.start
       alt {
         [] MQTT_PCO.receive(v_receive) {
           connection.client_state := Connected
           break;
         }
         [] MQTT_PCO.receive(mw_mqtt_message(mw_connack)) {
           setverdict(fail, "CONNACK contains wrong return code")
           break
         }
         [] t_timeout.timeout {
           setverdict(fail, "No CONNACK received")
           break;
         }
       }
     }
     else
     {
       setverdict(fail, "Client could not connect to ", PX_SUT_HOSTNAME, ":", PX_SUT_PORT)
     }
   }

   /*
    * @desc connect MQTT client with LWT
    * TODO: refactor f_mqtt_connect_[] functions
    */
   function f_mqtt_connect_03(BIT1n p_will_retain := '0'B) runs on MQTT_Client_MTC
   {
     // establish TCP connection
     if(f_ipl4_connect())
     {
       var integer v_return_code := 0

       var UTF8EncodedString v_client_id := f_utf8_from_charstring(credentials.clientId)
       var UTF8EncodedString v_will_topic := f_utf8_from_charstring(PX_TOPIC_NAME)
       var OctStringWithLength v_will_message := f_octstring_from_charstring(PX_WILL_MESSAGE);
       var UTF8EncodedString v_username := f_utf8_from_charstring(credentials.username)
       var OctStringWithLength v_password := f_octstring_from_charstring(credentials.password)

       var BIT1n v_will_flag := '1'B
       var template MQTT_v3_1_1_ConnectFlags v_flags := md_connect_credentials_lwt(v_will_flag, p_will_retain, -)
       var template MQTT_v3_1_1_ConnectPayload v_payload := m_connect_payload_credentials_lwt(v_client_id, v_will_topic, v_will_message, v_username, v_password)
       var template MQTT_v3_1_1_Message v_connect_packet := m_connect_message_base_02(v_flags, v_payload)
       var template MQTTasp_Message vt_connect := m_mqtt_message_conn(v_connect_packet, connection);

       MQTT_PCO.send(valueof(vt_connect))

       var template MQTTasp_Message v_receive := mw_mqtt_message(mw_connack_rc(v_return_code))
       timer t_timeout := PX_MAX_RESPONSE_TIME;
       t_timeout.start
       alt {
         [] MQTT_PCO.receive(v_receive) {
           connection.client_state := Connected
           break;
         }
         [] MQTT_PCO.receive(mw_mqtt_message(mw_connack)) {
           setverdict(fail, "CONNACK contains wrong return code")
           break
         }
         [] t_timeout.timeout {
           setverdict(fail, "No CONNACK received")
           break;
         }
       }
     }
     else
     {
       setverdict(fail, "Client could not connect to ", PX_SUT_HOSTNAME, ":", PX_SUT_PORT)
     }
   }

   function f_mqtt_send_publish(MQTT_v3_1_1_Publish p_publish) runs on MQTT_Client_MTC
   {
     f_send_publish(connection, p_publish)
   }

   function f_mqtt_send_publish_header(MQTT_v3_1_1_PublishHeader p_header, octetstring p_payload := 'A5A5A5'O) runs on MQTT_Client_MTC
   {
     var universal charstring v_topic_string := PX_TOPIC_NAME
     var UTF8EncodedString v_topic := { stringLength := lengthof(v_topic_string), stringItem := v_topic_string }
     var template MQTT_v3_1_1_Publish v_publish;

     if(p_header.qos_level == AT_MOST_ONCE_DELIVERY)
     {
       v_publish := t_publish_packet_qos_0(p_header, v_topic, p_payload)
     }
     else
     {
       var integer v_packet_id := f_random_packet_id()
       v_publish := t_publish_packet(p_header, v_packet_id, v_topic, p_payload)
     }

     f_send_publish(connection, valueof(v_publish))
   }

   function f_mqtt_receive_publish(template MQTT_v3_1_1_Publish p_publish) runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expect := mw_mqtt_message({msg := { publish := p_publish }})
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect) {
         setverdict(pass, "Received PUBLISH")
         break;
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No PUBLISH received")
         break;
       }
     }
     t_timeout.stop
   }

   function f_mqtt_receive_no_publish() runs on MQTT_Client_MTC
   {
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(MQTT_ASP_Event:?) {
         setverdict(fail, "Received unexpected ASP Event message")
         break;
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(pass, "No PUBLISH received")
         break;
       }
     }
     t_timeout.stop
   }

   /*
    * @desc similar to f_mqtt_receive_publish but intented to be used for receiving large payloads which might require longer than PX_MAX_RESPONSE_TIME!
    */
   function f_mqtt_receive_large_publish(template MQTT_v3_1_1_Publish p_publish, float p_timeout, integer p_estimated_size) runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expect := mw_mqtt_message({msg := { publish := p_publish }})
     var MQTTasp_Message v_received
     timer t_timeout := p_timeout;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect) {
         setverdict(pass, "Received PUBLISH")
         break;
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "Receive PUBLISH timed out after ", p_timeout, " sec. for transmission of ", p_estimated_size, " of Bytes")
         break;
       }
     }
     t_timeout.stop
   }

   /*
   * @desc wati for a PUBLISH message with QoS 1 and response with PUBACK and invalid header flags
   */
   function f_mqtt_response_invalid_puback() runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expect := mw_mqtt_message(mdw_publish_qos(AT_LEAST_ONCE_DELIVERY))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect) -> value v_received {
         // get packet_id
         var integer v_packet_id := v_received.msg.msg.publish.packet_identifier
         // create PUBACK with invalid header_flags
         var BIT4n v_puback_flags := '1111'B
         var template MQTT_v3_1_1_Message v_puback := m_puback_flags(v_packet_id, v_puback_flags)
         var template MQTTasp_Message v_response := m_mqtt_message_conn(v_puback, connection)
         MQTT_PCO.send(v_response)

         var MQTT_ASP_Event v_asp_event
         alt {
           [] MQTT_PCO.receive(MQTT_ASP_Event:?) -> value v_asp_event {
             setverdict(pass, "IUT closed network connection correctly")
             break;
           }
           [] t_timeout.timeout {
             setverdict(fail, "IUT must close network connection")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No PUBLISH received")
         break;
       }
     }
     t_timeout.stop
   }

   /*
   * @desc wati for a PUBLISH message with QoS 2 and response with PUBREC and invalid header flags
   */
   function f_mqtt_response_invalid_pubrec() runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expect := mw_mqtt_message(mdw_publish_qos(EXACTLY_ONE_DELIVERY))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect) -> value v_received {
         // get packet_id
         var integer v_packet_id := v_received.msg.msg.publish.packet_identifier
         // create PUBREC with invalid header_flags
         var BIT4n v_pubrec_flags := '1111'B
         var template MQTT_v3_1_1_Message v_pubrec := m_pubrec_flags(v_packet_id, v_pubrec_flags)
         var template MQTTasp_Message v_response := m_mqtt_message_conn(v_pubrec, connection)
         MQTT_PCO.send(v_response)

         var MQTT_ASP_Event v_asp_event
         alt {
           [] MQTT_PCO.receive(MQTT_ASP_Event:?) -> value v_asp_event {
             setverdict(pass, "IUT closed network connection correctly")
             break;
           }
           [] t_timeout.timeout {
             setverdict(fail, "IUT must close network connection")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No PUBLISH received")
         break;
       }
     }
     t_timeout.stop
   }


   /*
   * @desc wati for a PUBLISH message with QoS 2 and response with PUBCOMP and invalid header flags
   */
   function f_mqtt_response_invalid_pubcomp() runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expect := mw_mqtt_message(mdw_publish_qos(EXACTLY_ONE_DELIVERY))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect) -> value v_received {
         // get packet_id
         var integer v_packet_id := v_received.msg.msg.publish.packet_identifier
         // create PUBREC with invalid header_flags
         var BIT4n v_pubrec_flags := '0000'B
         var template MQTT_v3_1_1_Message v_pubrec := m_pubrec_flags(v_packet_id, v_pubrec_flags)
         var template MQTTasp_Message v_response := m_mqtt_message_conn(v_pubrec, connection)
         MQTT_PCO.send(v_response)

         // receive PUBREL
         v_expect := mw_mqtt_message(mw_pubrel_packet_id(v_packet_id))
         alt {
           [] MQTT_PCO.receive(v_expect) {
             // create PUBCOMP with invalid header_flags
             var BIT4n v_pubcomp_flags := '1111'B
             var template MQTT_v3_1_1_Message v_pubcomp := m_pubcomp_flags(v_packet_id, v_pubcomp_flags)
             v_response := m_mqtt_message_conn(v_pubcomp, connection)
             MQTT_PCO.send(v_response)

             // wait for network close from IUT
             var MQTT_ASP_Event v_asp_event
             alt {
               [] MQTT_PCO.receive(MQTT_ASP_Event:?) -> value v_asp_event {
                 setverdict(pass, "IUT closed network connection correctly")
                 break;
               }
               [] t_timeout.timeout {
                 setverdict(fail, "IUT must close network connection")
                 break;
               }
             }
           }
           [] MQTT_PCO.receive(mw_mqtt_message(mw_pubrel)) {
             setverdict(fail, "Received PUBREL with wrong packet ID")
             break
           }
           [] t_timeout.timeout {
             setverdict(fail, "No PUBREL received")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "Received unexpected message ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No PUBLISH received")
         break;
       }
     }
     t_timeout.stop
   }

   /*
   * @desc wati for a PUBLISH message with QoS 2 and response with PUBREL and invalid header flags
   */
   function f_mqtt_response_invalid_pubrel() runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var QoS v_qos_level := EXACTLY_ONE_DELIVERY
     var MQTT_v3_1_1_PublishHeader v_pub_header := valueof(t_publish_header(-, v_qos_level, '0'B))
     var octetstring v_payload := 'A5A5A5'O

     var universal charstring v_topic_string := PX_TOPIC_NAME
     var UTF8EncodedString v_topic := { stringLength := lengthof(v_topic_string), stringItem := v_topic_string }
     var template MQTT_v3_1_1_Message v_publish := m_publish_message(v_pub_header, v_packet_id, v_topic, v_payload)
     var template MQTTasp_Message vt_msg := m_mqtt_message_conn(v_publish, connection)

     // send PUBLISH
     MQTT_PCO.send(valueof(vt_msg))

     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start

     // await PUBREC
     var template MQTTasp_Message v_expect := mw_mqtt_message(mw_pubrec_packet_id(v_packet_id))
     alt {
       [] MQTT_PCO.receive(v_expect) {
         // received PUBREC, now send PUBREL with invalid header_flags
         var BIT4n v_pubrel_flags := '1101'B
         var template MQTT_v3_1_1_Message v_pubrel := m_pubrel_flags(v_packet_id, v_pubrel_flags)
         var template MQTTasp_Message v_response := m_mqtt_message_conn(v_pubrel, connection)
         MQTT_PCO.send(valueof(v_response))

         // wait for network close from IUT
         var MQTT_ASP_Event v_asp_event
         alt {
           [] MQTT_PCO.receive(MQTT_ASP_Event:?) -> value v_asp_event {
             setverdict(pass, "IUT closed network connection correctly")
             break;
           }
           [] t_timeout.timeout {
             setverdict(fail, "IUT must close network connection")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) {
         setverdict(fail, "unexpected message received")
         break;
       }
       [] t_timeout.timeout {
         setverdict(fail, "No PUBREC received for ", v_packet_id)
         break;
       }
     }
     t_timeout.stop
   }

   function f_receive_ordered_pubrel() runs on MQTT_Client_MTC
   {
     var template MQTTasp_Message v_expected_publish := mw_mqtt_message(mdw_publish_qos(EXACTLY_ONE_DELIVERY));

     var MQTTasp_Message v_received;
     var integer v_publish_counter := 0
     var MessageFlowList v_message_flows

     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start

     alt {
       [] MQTT_PCO.receive(v_expected_publish) -> value v_received {
         var integer v_pid := v_received.msg.msg.publish.packet_identifier
         f_send_pubrec(connection, v_pid)

         v_message_flows[v_publish_counter] := { packet_id := v_pid, message_state := e_wait_pubrel }
         v_publish_counter := v_publish_counter + 1
         repeat
       }
       [] MQTT_PCO.receive(mw_mqtt_message(mw_pubrel)) -> value v_received {
         var integer v_pid := v_received.msg.msg.pubrel.packet_identifier
         var integer v_idx := f_get_index_by_id(v_message_flows, v_pid)
         var AT_MOST_ONCE_DELIVERY_STATE v_idx_state := v_message_flows[v_idx].message_state

         // first check if the pubrel was expected
         if(v_idx < 0 or v_idx_state != e_wait_pubrel) { setverdict(fail, "Receveid unexpected PUBREL with ID ", v_pid) }

         if(v_idx == 0) {
           // first received pub_id can be directly processed
           v_message_flows[v_idx] := { packet_id := v_pid, message_state := e_completed }
           f_send_pubcomp(connection, v_pid)
           repeat
         } else {
           // this is a consecutive pub_id, check if previous pubrel was already processed!
           var integer v_idx_prev := v_idx - 1; // the previous message flow
           var AT_MOST_ONCE_DELIVERY_STATE v_idx_state_prev := v_message_flows[v_idx_prev].message_state // flow state of the previous message
           if(v_idx_state_prev == e_completed) {
             v_message_flows[v_idx] := { packet_id := v_pid, message_state := e_completed }
             setverdict(pass, "Received PUBREL messages in correct order")
             f_send_pubcomp(connection, v_pid)
           } else {
             setverdict(fail, "Received out of order PUBREL message with ID ", v_received.msg.msg.pubrel.packet_identifier)
           }
         }
       }
       [] MQTT_PCO.receive(mw_mqtt_message(mw_publish_basic)) -> value v_received {
         setverdict(inconc, "Received unexpeceted PUBLISH with QoS ", v_received.msg.msg.publish.header.qos_level)
         break
       }
       [] MQTT_PCO.receive(MQTTasp_Message : ?) -> value v_received {
         setverdict(fail, "Received unexpected message: ", v_received)
         break
       }
       [] t_timeout.timeout {
         setverdict(fail, "Time out without PUBLISH")
         break
       }
     }
   }

   function f_mqtt_subscribe(QoS p_requested_qos) runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var universal charstring v_topic_filter := PX_TOPIC_NAME
     var template MQTT_v3_1_1_SubscribePayload v_subscribe_payload := m_subscribe_payload(PX_TOPIC_NAME, p_requested_qos)
     var MQTT_v3_1_1_SubscribePayloadList v_subscribe_payload_list := {valueof(v_subscribe_payload)}
     var template MQTT_v3_1_1_Subscribe v_subscribe := m_subscribe_packet(v_packet_id, v_subscribe_payload_list)

     f_send_subscribe(connection, valueof(v_subscribe))

     // wait for suback
     var template MQTTasp_Message v_expect_suback := mw_mqtt_message(mw_suback_packet_id(v_packet_id))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect_suback) {
         break;
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "SUBACK was expected, received ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No SUBACK received for ", v_packet_id)
         break;
       }
     }
     t_timeout.stop
   }

   /*
    * @desc subscribe to PX_TOPIC_NAME and expect a retained message
    */
   function f_mqtt_subscribe_retained(QoS p_requested_qos, template MQTT_v3_1_1_Publish p_publish, boolean p_fail_on_timeout := true) runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var universal charstring v_topic_filter := PX_TOPIC_NAME
     var template MQTT_v3_1_1_SubscribePayload v_subscribe_payload := m_subscribe_payload(PX_TOPIC_NAME, p_requested_qos)
     var MQTT_v3_1_1_SubscribePayloadList v_subscribe_payload_list := {valueof(v_subscribe_payload)}
     var template MQTT_v3_1_1_Subscribe v_subscribe := m_subscribe_packet(v_packet_id, v_subscribe_payload_list)

     f_send_subscribe(connection, valueof(v_subscribe))

     // wait for suback
     var template MQTTasp_Message v_expect_suback := mw_mqtt_message(mw_suback_packet_id(v_packet_id))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME;
     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect_suback) {
         // after SUBACK wait for the retained message
         var template MQTTasp_Message v_expect_retain_pub := mw_mqtt_message({msg := { publish := p_publish }})
         alt {
           [] MQTT_PCO.receive(v_expect_retain_pub) {
             setverdict(pass, "Received retained message")
           }
           [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
             if(match(v_received, mw_mqtt_message(mw_publish_retain_qos0('0'B))))
             {
               // v_received does not match v_expect_retain_pub; probably because of the missing retain flag
               // this branch gives a more precise verdict message
               setverdict(fail, "Received PUBLISH was not marked as retained. received: ", v_received)
             }
             else
             {
               setverdict(fail, "Retained PUBLISH was expected, received ", v_received)
             }
           }
           [p_fail_on_timeout] t_timeout.timeout {
             setverdict(fail, "No retained PUBLISH received")
             break;
           }
           [not p_fail_on_timeout] t_timeout.timeout {
             setverdict(pass, "No retained PUBLISH received")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received{
         setverdict(fail, "SUBACK was expected, received ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No SUBACK received for ", v_packet_id)
         break;
       }
     }

     t_timeout.stop
   }

   /*
    * @desc subscribe to PX_TOPIC_NAME and check there is no retained message
    */
   function f_mqtt_subscribe_no_retained(QoS p_requested_qos) runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var universal charstring v_topic_filter := PX_TOPIC_NAME
     var template MQTT_v3_1_1_SubscribePayload v_subscribe_payload := m_subscribe_payload(PX_TOPIC_NAME, p_requested_qos)
     var MQTT_v3_1_1_SubscribePayloadList v_subscribe_payload_list := {valueof(v_subscribe_payload)}
     var template MQTT_v3_1_1_Subscribe v_subscribe := m_subscribe_packet(v_packet_id, v_subscribe_payload_list)

     f_send_subscribe(connection, valueof(v_subscribe))

     // wait for suback
     var template MQTTasp_Message v_expect_suback := mw_mqtt_message(mw_suback_packet_id(v_packet_id))
     var MQTTasp_Message v_received
     timer t_timeout := PX_MAX_RESPONSE_TIME

     t_timeout.start
     alt {
       [] MQTT_PCO.receive(v_expect_suback) {
         // after SUBACK wait for the retained message
         var template MQTTasp_Message v_publish_all := mw_mqtt_message(mw_publish_all)
         alt {
           [] MQTT_PCO.receive(v_publish_all) {
             setverdict(fail, "Received unexpected retained message")
           }
           [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
             setverdict(fail, "No message was expected, received ", v_received)
           }
           [] t_timeout.timeout {
             setverdict(pass, "Retained message removed correctly")
             break;
           }
         }
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received{
         setverdict(fail, "SUBACK was expected, received ", v_received)
       }
       [] t_timeout.timeout {
         setverdict(fail, "No SUBACK received for ", v_packet_id)
         break;
       }
     }

     t_timeout.stop
   }

   /*
    * @desc subscribe to PX_TOPIC_NAME and check there is no retained message
    */
   function f_mqtt_receive_ipl4_close(float p_timeout := 0.0) runs on MQTT_Client_MTC
   {
     if(p_timeout <= 0.0) {
       p_timeout := PX_MAX_RESPONSE_TIME
     }
     timer t_timeout := p_timeout

     var MQTTasp_Message v_received

     t_timeout.start
     alt {
       [] MQTT_PCO.receive(MQTT_ASP_Event:?) {
         setverdict(pass, "IUT closed network connection correctly")
         break;
       }
       [] MQTT_PCO.receive(MQTTasp_Message:?) -> value v_received {
         setverdict(fail, "No message was expected, received ", v_received)
         break;
       }
       [] t_timeout.timeout {
         setverdict(fail, "IUT must close network connection")
         break;
       }
     }

     t_timeout.stop
   }

   function f_ipl4_probe(float p_timeout := 0.0, boolean p_fail_event := true) runs on MQTT_Client_MTC
   {
       if(p_timeout <= 0.0) {
         p_timeout := PX_MAX_RESPONSE_TIME
       }
       timer t_timeout := p_timeout
       var MQTT_ASP_Event v_asp_event

       t_timeout.start
       alt {
         [p_fail_event] MQTT_PCO.receive(MQTT_ASP_Event:?) {
           setverdict(fail, "IUT closed network connection")
           break;
         }
         [p_fail_event] t_timeout.timeout {
           setverdict(pass, "IUT did not close network connection")
           break;
         }
         [not p_fail_event] MQTT_PCO.receive(MQTT_ASP_Event:?) {
           setverdict(pass, "IUT did not closed network connection")
           break;
         }
         [p_fail_event] t_timeout.timeout {
           setverdict(fail, "IUT closed network connection")
           break;
         }
     }
   }

   /*
   * TODO: describe and reference to CVE for MQTT.js
   * @desc send a specifically malformed MQTT Packet:
   */
   function f_send_malformed_subscribe_01() runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var UCHAR0_65535 v_topic_filter := PX_TOPIC_NAME
     var INT_BIT16_MSB v_filter_len := lengthof(v_topic_filter) + 1  // this additional byte is significant
     var octetstring v_filter_len_raw := int2oct(v_filter_len, 2)       // reqired as erroneous only via values seems encode incorrectly
     var QoS v_req_qos := AT_MOST_ONCE_DELIVERY

     // update the template
     @update(m_subscribe_packet_02) with
     {
       erroneous (payload[0].filterLength) "value(raw) := v_filter_len_raw";
     }

     var template MQTT_v3_1_1_SubscribePayload v_payload := m_subscribe_payload(v_topic_filter, v_req_qos)

     var template MQTT_v3_1_1_SubscribePayloadList v_payload_list := { v_payload }
     var template MQTT_v3_1_1_Subscribe v_malformed_subscribe := m_subscribe_packet_02(v_packet_id, v_payload_list)
     var MQTT_v3_1_1_Subscribe v_malformed_subscribe_val := valueof(v_malformed_subscribe)

     fw_mqtt_subscribe(v_malformed_subscribe_val)

     // clear
     @update(m_subscribe_packet_02)
   }

   /*
   * @ref https://mosquitto.org/blog/2018/09/security-advisory-cve-2018-12543/
   * @desc send a specifically malformed MQTT Packet:
   */
   function f_send_malformed_publish_01() runs on MQTT_Client_MTC
   {
     var integer v_packet_id := f_random_packet_id()
     var UTF8EncodedString v_topic_name := f_utf8_from_charstring("$TEST")
     var QoS v_req_qos := AT_MOST_ONCE_DELIVERY
     var MQTT_v3_1_1_PublishHeader v_header := valueof(t_publish_header)
     var octetstring v_payload := 'AAAAAA'O

     var template MQTT_v3_1_1_Publish v_malformed_publish := t_publish_packet_qos_0(v_header, v_topic_name, v_payload)

     fw_mqtt_publish(valueof(v_malformed_publish))
   }

   import from MQTT_Functions all;
   function f_malformed_connect_01(integer v_num := 10, integer p_string_len := 65535) runs on MQTT_Client_MTC
   {
     // prepare variables
     var integer v_packet_id := f_random_packet_id()
     var universal charstring v_long_string := f_test_charstring(p_string_len)
     var UTF8EncodedString v_client_id := f_utf8_from_charstring(v_long_string)
     var UTF8EncodedString v_will_topic := f_utf8_from_charstring(v_long_string)
     var OctStringWithLength v_will_msg := f_octstring_from_charstring(v_long_string)
     var UTF8EncodedString v_user_name := f_utf8_from_charstring(v_long_string)
     var OctStringWithLength v_password := f_octstring_from_charstring(v_long_string)

     var template MQTT_v3_1_1_ConnectFlags v_flags := md_connect_credentials_lwt('1'B, '1'B, EXACTLY_ONE_DELIVERY, '0'B)
     var template MQTT_v3_1_1_ConnectPayload v_payload := m_connect_payload_credentials_lwt(v_client_id, v_will_topic, v_will_msg, v_user_name, v_password)
     var template MQTT_v3_1_1_Connect vt_connect := m_connect_packet_mqtt4(v_flags, v_payload)
     var MQTT_v3_1_1_Connect v_connect := valueof(vt_connect)

     for(var integer v_idx := 0; v_idx < v_num; v_idx := v_idx + 1) {
       if(f_ipl4_connect()) {
         f_send_connect(v_connect)
         f_sleep(0.5)
         f_ipl4_disconnect()
       } else {
         setverdict(inconc, "Could not connect to IUT")
       }
     }
   }

   // TODO: rename MQTT_Functions_Protocol.f_send_disconnect() to f_mqtt_disconnect()
   function f_mqtt_disconnect() runs on MQTT_Client_MTC
   {
     f_send_disconnect()
   }
} // module MQTT_Client_Behaviors
