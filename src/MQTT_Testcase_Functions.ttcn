/*******************************************************************************
* Copyright (c) 2018 Relayr GmbH
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html 
*
* Contributors:
*   Alexander Kaiser
*   Sascha Kretzschmann
*******************************************************************************/
module MQTT_Testcase_Functions {

import from MQTT_TestSystem all;
import from MQTT_TypesAndValues all;
import from MQTT_Functions all;
import from MQTT_Templates all;

import from MQTT_v3_1_1_Types all;

group connectFunctionsGroup
{
      function f_TC_MQTT_BROKER_CONNECT_001() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_flags(p_client_id := v_clientId, p_flags := '1111'B);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_002() runs on MQTT_Client
      {
        const UCHAR0_65535 c_protocolName := "TTQM";
        var UTF8EncodedString v_clientId := f_getClientId();
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_protocol_name(v_clientId, c_protocolName);
        f_send(valueof(v_conMsg));
    
        var IPL4_Response v_response := f_receive();
        var template IPL4_Response v_connack := { receivedMsg :=  tw_connack };
    
        if(ischosen(v_response.aspEvent))
        {
          if(ischosen(v_response.aspEvent.connClosed))
          {
            setverdict(pass, "IUT does not accept incorrect Protocol Names");
          }
          else
          {
            setverdict(inconc, "IUT responds with ", v_response.aspEvent)
          }
        }
        else if(match(v_response, v_connack))
        {
          setverdict(pass, "IUT accepts incorrect Protocol Names");
          f_disconnectMqtt();
        }
        else
        {
          setverdict(fail, v_response);
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_003() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_credentials(v_clientId, v_username, v_password);
        f_send(valueof(v_conMsg));
    
        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();
    
        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
        
        f_disconnectMqtt();
      }
      
      function f_TC_MQTT_BROKER_CONNECT_004() runs on MQTT_Client
      {
        var UTF8EncodedString v_clientId := f_getClientId();
    
        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_reserved;
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_empty(v_clientId);
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_005() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag);
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_credentials(v_clientId, v_username, v_password);
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_006() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '1'B;
        const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };
    
        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_007() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_008() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  RESERVED;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };
    
        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_009() runs on MQTT_Client
      {
        const universal charstring c_wm := "Will Message";
        const BIT1n c_will_flag := '1'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;
        const OctStringWithLength c_will_msg := { stringLength := lengthof(c_wm), stringItem := unichar2oct(c_wm) };
    
        var UTF8EncodedString v_will_topic := f_getConcatenatedTopicName("LWT");
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, v_will_topic, c_will_msg));
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();
    
        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
        
        f_disconnectMqtt();
      }
      
      function f_TC_MQTT_BROKER_CONNECT_010() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '1'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_011() runs on MQTT_Client
      {
        const BIT1n c_will_flag := '0'B;
        const BIT1n c_will_retain := '0'B;
        const QoS c_qos :=  AT_MOST_ONCE_DELIVERY;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_will_retain, p_will_qos := c_qos, p_will_flag := c_will_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();
    
        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
        
        f_disconnectMqtt();
      }
      
      function f_TC_MQTT_BROKER_CONNECT_012() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '1'B;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_013() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '0'B;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
    
        var template (value) MQTT_v3_1_1_ConnectFlags v_conFlags := t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag);
        var template (value) MQTT_v3_1_1_ConnectPayload v_conPayload := t_connect_payload_username(v_clientId, v_username);
    
        var template MQTT_v3_1_1_Message v_conMsg := t_connect_with_payload(v_conFlags, v_conPayload);
        f_send(valueof(v_conMsg));
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_014() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '0'B;
    
        var UTF8EncodedString v_clientId := f_getClientId();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_empty(v_clientId));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_015() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '0'B;
        const BIT1n c_password_flag := '0'B;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_password(v_clientId, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_016() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_username(v_clientId, v_username));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_017() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;
    
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var UTF8EncodedString v_clientId := { stringLength := 24, stringItem := "01234567abcdefghABCDEFGH" };
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        // TODO: only pass verdicts?
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT accepts only clientIds up to 23 Bytes");
        }
        else
        {
          setverdict(pass, "IUT accepts clientIds longer than 23 Bytes");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_018() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;
    
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var UTF8EncodedString v_clientId := { stringLength := 23, stringItem := "<([^°+-_!§$%&/=?ß@üäö.," };
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        // TODO: only pass verdicts?
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT does not accept clientIds with special characters");
        }
        else
        {
          setverdict(pass, "IUT accepts clientIds with special characters");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_019() runs on MQTT_Client
      {
        const BIT1n c_user_name_flag := '1'B;
        const BIT1n c_password_flag := '1'B;
    
        const UTF8EncodedString c_zero_byte_clientid := {stringLength := 0, stringItem := ""};
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials(p_user_name_flag := c_user_name_flag, p_password_flag := c_password_flag));
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(c_zero_byte_clientid, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        // wait for CONNACK with return_code := 0
        var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
        var IPL4_Response v_response := f_receive();
    
        if(match(v_response, v_expected))
        {
          setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
    
        f_disconnectMqtt();
      }
      
      function f_TC_MQTT_BROKER_CONNECT_020() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
        const UTF8EncodedString c_invalid_clientId := {stringLength := 0, stringItem := "MyClientId" };
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);
    
        // prepare invalid client identifier
        // TODO: uncomment when Titan Designer supports @update or a standard complient solution is found
        var octetstring v_oCID := 'EDA080'O; // UTF-8 for U+D800
        var octetstring v_oLen := int2oct(lengthof(v_oCID), 2);
        @update(t_connect_payload_credentials)
        with {
          erroneous (client_identifier.stringItem) "value(raw) := v_oCID";
          erroneous (client_identifier.stringLength) "value(raw) := v_oLen";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(c_invalid_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          f_disconnectMqtt();
          setverdict(fail, "IUT MUST close the Network Connection");
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_021() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
        const UTF8EncodedString c_invalid_clientId := {stringLength := 0, stringItem := "MyClientId" };
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);
    
        // prepare invalid client identifier
        // TODO: uncomment when Titan Designer supports @update or a standard complient solution is found
        var octetstring v_oCID := c_utf8_bom & unichar2oct(c_invalid_clientId.stringItem) & '00'O;
        var octetstring v_oLen := int2oct(lengthof(v_oCID), 2);
    
        @update(t_connect_payload_credentials)
        with {
          erroneous (client_identifier.stringItem) "value(raw) := v_oCID";
          erroneous (client_identifier.stringLength) "value(raw) := v_oLen";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(c_invalid_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_022() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
    
        const BIT1n c_wr := '0'B;                     // Will Retain Flag
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;     // Will QoS
        const BIT1n c_wf := '1'B;                     // Will Flag
    
        const universal charstring c_wm := "Will Message";
        const octetstring c_os_wm := unichar2oct(c_wm);
        const UTF8EncodedString c_willTopic := { stringLength := 0, stringItem := "dummyTopic"};
        const OctStringWithLength c_willMsg := { stringLength := lengthof(c_os_wm), stringItem := c_os_wm};
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_wr, p_will_qos := c_qos, p_will_flag := c_wf));
    
        // prepare invalid will topic
        // TODO: uncomment when Titan Designer supports @update
        @update(t_connect_payload_lwt)
        with {
          erroneous (will_topic) "value(raw) := c_utf8_bom & 'D800'O";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, c_willTopic, c_willMsg));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_023() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
    
        const BIT1n c_wr := '0'B;                     // Will Retain Flag
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;     // Will QoS
        const BIT1n c_wf := '1'B;                     // Will Flag
    
        const universal charstring c_wm := "Will Message";
        const octetstring c_os_wm := unichar2oct(c_wm);
        const UTF8EncodedString c_willTopic := { stringLength := 0, stringItem := "dummyTopic"};
        const OctStringWithLength c_willMsg := { stringLength := lengthof(c_os_wm), stringItem := c_os_wm};
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_lwt(p_will_retain := c_wr, p_will_qos := c_qos, p_will_flag := c_wf));
    
        // prepare invalid will topic
        // TODO: uncomment when Titan Designer supports @update
        @update(t_connect_payload_lwt)
        with {
          erroneous (will_topic) "value(raw) := c_utf8_bom & '0000'O";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_lwt(v_clientId, v_username, v_password, c_willTopic, c_willMsg));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_024() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);
    
        // prepare invalid will topic
        // TODO: uncomment when Titan Designer supports @update
        @update(t_connect_payload_credentials)
        with {
          erroneous (user_name) "value(raw) := c_utf8_bom & 'D800'O";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      
      function f_TC_MQTT_BROKER_CONNECT_025() runs on MQTT_Client
      {
        const octetstring c_utf8_bom := 'EFBBBF'O;
    
        var UTF8EncodedString v_clientId := f_getClientId();
        var UTF8EncodedString v_username := f_getUsername();
        var OctStringWithLength v_password := f_getPassword();
    
        var MQTT_v3_1_1_ConnectFlags v_conFlags := valueof(t_connectFlags_credentials);
    
        // prepare invalid will topic
        // TODO: uncomment when Titan Designer supports @update
        @update(t_connect_payload_credentials)
        with {
          erroneous (user_name) "value(raw) := c_utf8_bom & '0000'O";
        }
    
        var MQTT_v3_1_1_ConnectPayload v_conPayload := valueof(t_connect_payload_credentials(v_clientId, v_username, v_password));
    
        var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_with_payload(v_conFlags, v_conPayload));
        f_send(v_conMsg);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
} // connectFunctionsGroup
    
group connackFunctionsGroup
{
    function f_TC_MQTT_BROKER_CONNACK_001() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username, v_password));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and return code 0x00");
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_002() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, v_username, v_password));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT accepted connection with clean session set to 1");
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_003() runs on MQTT_Client
    {
      /* Initial Condition */
      f_connectMqtt(p_cleanSession := '0'B);
      f_disconnectMqtt();
  
      /* Test Purpose */
      f_connectNetwork("mqtt_server");
  
      const BIT1n c_cleanSession := '0'B;
      const BIT1n c_sessionPresent := '1'B;
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(v_clientId, v_username, v_password, c_cleanSession));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack(c_sessionPresent) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT restored present session");
  
        // disconnect MQTT Session
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_004() runs on MQTT_Client
    {
      /* Initial Condition */
      f_connectMqtt(p_cleanSession := '1'B);
      f_disconnectMqtt();
  
      /* Test Purpose */
      f_connectNetwork("mqtt_server");
  
      const BIT1n c_cleanSession := '0'B;
      const BIT1n c_sessionPresent := '0'B;
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(v_clientId, v_username, v_password, c_cleanSession));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack(c_sessionPresent) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT had no present session to restore");
  
        // disconnect MQTT Session
        f_disconnectMqtt();
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        // TODO: check if MQTT Connection needs to be closed!
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_005() runs on MQTT_Client
    {
      var UTF8EncodedString v_clientId := f_getClientId();
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      const integer c_protoLevel := 255;
      var template MQTT_v3_1_1_Message v_conMsg := t_connect_protocol_level(v_clientId, v_username, v_password, c_protoLevel);
      f_send(valueof(v_conMsg));
  
      // wait for CONNACK with return_code := 0
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_unacceptable_version };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and Return Code 0x01");
  
        // wait for Network Disconnect
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        setverdict(fail, "IUT send wrong response ", v_response);
        f_disconnectMqtt();
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_006() runs on MQTT_Client
    {
      var UTF8EncodedString v_username := f_getUsername();
      var OctStringWithLength v_password := f_getPassword();
  
      const BIT1n c_clean_session := '0'B;
      const UTF8EncodedString c_zero_byte_clientid := {stringLength := 0, stringItem := ""};
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_session(c_zero_byte_clientid, v_username, v_password, c_clean_session));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0x02
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_id_rejected };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and return code 0x02");
  
        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after refusing connection");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
        f_disconnectMqtt();
      }
    }
    
    function f_TC_MQTT_BROKER_CONNACK_007() runs on MQTT_Client
    {
      // TODO: Test Case not implemented yet!
    }
    
    function f_TC_MQTT_BROKER_CONNACK_008() runs on MQTT_Client
    {
      // build invalid credentials
      const universal charstring c_uc_invalid_username := "invalid_username";
      const octetstring c_invalid_password_string := '113355'O;
  
      var UTF8EncodedString v_clientId := f_getClientId();
      const UTF8EncodedString c_invalid_username := { stringLength := lengthof(c_uc_invalid_username), stringItem := c_uc_invalid_username};
      const OctStringWithLength c_invalid_password := { stringLength := lengthof(c_invalid_password_string), stringItem := c_invalid_password_string };
  
      var MQTT_v3_1_1_Message v_conMsg := valueof(t_connect_credentials(v_clientId, c_invalid_username, c_invalid_password));
      f_send(v_conMsg);
  
      // wait for CONNACK with return_code := 0x04
      var template IPL4_Response v_expected := { receivedMsg :=  tw_connack_bad_credentials };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with ACK and return code 0x04");
  
        // wait IUT to close the Network Connection
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly after refusing connection");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection after refusing connection");
          f_disconnectMqtt();
        }
      }
      else
      {
        // TODO: how to handle brokers which don't require credentials??
        v_expected := { receivedMsg :=  tw_connack };
        if(match(v_response, v_expected))
        {
          setverdict(inconc, "IUT does not require credentials");
        }
        else
        {
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }

        f_disconnectMqtt();
      }
    }
} // connackFunctionsGroup

group subscribeFunctionsGroup
{
     function f_TC_MQTT_BROKER_SUBSCRIBE_001() runs on MQTT_Client
     {
        f_connectMqtt();
    
        var integer v_pid := f_randomPacketId();
        const QoS c_qos := AT_MOST_ONCE_DELIVERY;
        const BIT4n c_header_flags := '1101'B;
    
        var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
    
        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_header_flags := c_header_flags, p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
        f_send(v_subscribe);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }
     
     function f_TC_MQTT_BROKER_SUBSCRIBE_005() runs on MQTT_Client
     {
        f_connectMqtt();
    
        var integer v_pid := f_randomPacketId();
    
        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_empty_payload(p_packet_id := v_pid));
        f_send(v_subscribe);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }
     
     function f_TC_MQTT_BROKER_SUBSCRIBE_006() runs on MQTT_Client
     {
        // TODO: Test Case not implented yet
     }
     
     function f_TC_MQTT_BROKER_SUBSCRIBE_007() runs on MQTT_Client
     {
        f_connectMqtt();
    
        var integer v_pid := f_randomPacketId();
        const QoS c_qos := RESERVED;
        var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
    
        var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
        f_send(v_subscribe);
    
        if(f_receiveNetworkClosedEvent())
        {
          setverdict(pass, "IUT closed the Network Connection correctly");
        }
        else
        {
          setverdict(fail, "IUT MUST close the Network Connection");
          f_disconnectMqtt();
        }
     }
} // subscribeFunctionsGroup

group subackFunctionsGroup
{
    function f_TC_MQTT_BROKER_SUBACK_001() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      var template IPL4_Response v_expected := { receivedMsg := tw_suback_header_flags };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and correct header flags");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_SUBACK_002() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      var template IPL4_Response v_expected := { receivedMsg := tw_suback_packet_id(v_pid) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and correct packet_identifier ", v_pid);
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_SUBACK_003() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_MOST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      // wait for SUBACK with return_code := 0x00
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_SUBACK_004() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_LEAST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      // wait for SUBACK with return_code := 0x01
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          // response was a SUBACK, check the payload
          if(sizeof(v_response.receivedMsg.msg.suback.payload) == 1)
          {
            var integer v_rc := v_response.receivedMsg.msg.suback.payload.return_code[0];
            if(v_rc > c_return_code)
            {
              setverdict(fail, "SUBACK return code ", v_rc, " is greater than requested ");
            }
            else
            {
              // NOTE: SUBACK returns the maximum granted QoS not the requested!
              var QoS v_qos_granted;
              int2enum(v_rc, v_qos_granted);
              setverdict(pass, "IUT granted QoS ", v_qos_granted, " although ", c_qos, " was requested");
            }
          }
          else
          {
            // response SUBACK has more return codes than subscriptions
            setverdict(fail, "SUBACK contains more return codes than subscriptions");
          }
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_SUBACK_005() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := EXACTLY_ONE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      // wait for SUBACK with return_code := 0x02
      const integer c_return_code := enum2int(c_qos);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          // response was a SUBACK, check the payload
          if(sizeof(v_response.receivedMsg.msg.suback.payload) == 1)
          {
            var integer v_rc := v_response.receivedMsg.msg.suback.payload.return_code[0];
            if(v_rc > c_return_code)
            {
              setverdict(fail, "SUBACK return code ", v_rc, " is greater than requested ");
            }
            else
            {
              // NOTE: SUBACK returns the maximum granted QoS not the requested!
              var QoS v_qos_granted;
              int2enum(v_rc, v_qos_granted);
              setverdict(pass, "IUT granted QoS ", v_qos_granted, " although ", c_qos, " was requested");
            }
          }
          else
          {
            // response SUBACK has more return codes than subscriptions
            setverdict(fail, "SUBACK contains more return codes than subscriptions");
          }
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered incorrectly with ", v_response);
        }
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_SUBACK_006() runs on MQTT_Client
    {
      f_connectMqtt();
  
      const charstring c_topicPrefix := "/prefix";
  
      var integer v_pid := f_randomPacketId();
      const QoS c_qos := AT_MOST_ONCE_DELIVERY;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      // this should ensure that the subscription goes to a valid but not accessable topic
      v_topic.stringItem := c_topicPrefix & v_topic.stringItem;
      v_topic.stringLength := v_topic.stringLength + lengthof(c_topicPrefix);
  
      var MQTT_v3_1_1_Message v_subscribe := valueof(t_subscribe_topic(p_packet_id := v_pid, p_topic_filter := v_topic.stringItem, p_qos := c_qos));
      f_send(v_subscribe);
  
      // wait for SUBACK with return_code := 0x80
      const integer c_return_code := hex2int('80'H);
      var MQTT_v3_1_1_SubackPayload v_payload := valueof(t_subackPayload({c_return_code}));
      var template IPL4_Response v_expected := { receivedMsg := tw_suback(v_pid, v_payload) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with SUBACK and return code ", c_return_code);
      }
      else
      {
        if(ispresent(v_response.receivedMsg.msg.suback))
        {
          setverdict(inconc, "IUT seems not to implement Access restrictions for subscriptions");
        }
        else
        {
          // response was not a SUBACK
          setverdict(fail, "IUT answered not with SUBACK ", v_response);
        }
      }
  
      f_disconnectMqtt();
    }
}  // subackFunctionsGroup
    
group unsubscribeFunctionsGroup
{
    function f_TC_MQTT_BROKER_UNSUBSCRIBE_001() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic('1101'B, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);
  
      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        f_disconnectMqtt();
        setverdict(fail, "IUT MUST close the Network Connection");
      }
    }
    
    function f_TC_MQTT_BROKER_UNSUBSCRIBE_002() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := 0;
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);
  
      var IPL4_Response v_response := f_receive();
  
      // The standard references in section 3.10.2 to section 2.3.1 which is not applicable to UNSUBSCRIBE
      setverdict(inconc, "Standard inconclusive");      
    }
    
    function f_TC_MQTT_BROKER_UNSUBSCRIBE_004() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
  
      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_emtpy_topic(v_pid));
      f_send(v_unsubscribe);
  
      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        f_disconnectMqtt();
        setverdict(fail, "IUT MUST close the Network Connection");
      }
    }
} // unsubscribeFunctionsGroup

group unsubackFunctionsGroup
{
    function f_TC_MQTT_BROKER_UNSUBACK_001() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);
  
      var template IPL4_Response v_expected := { receivedMsg := tw_unsuback_header_flags };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with UNSUBACK and correct header flags");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
    
    function f_TC_MQTT_BROKER_UNSUBACK_002() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var integer v_pid := f_randomPacketId();
      var UTF8EncodedString v_topic := f_getConcatenatedTopicName("data");
  
      var MQTT_v3_1_1_Message v_unsubscribe := valueof(t_unsubscribe_topic(-, v_pid, v_topic.stringItem));
      f_send(v_unsubscribe);
  
      var template IPL4_Response v_expected := { receivedMsg := tw_unsuback_packed_id(v_pid) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly with UNSUBACK and correct packet identifier");
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
} // unsubackFunctionsGroup

group pingreqFunctionsGroup
{
    function f_TC_MQTT_BROKER_PINGREQ_001() runs on MQTT_Client 
    {
      f_connectMqtt();
  
      var MQTT_v3_1_1_Message v_pingReq := valueof(t_ping_req('1111'B));
      f_send(v_pingReq);
  
      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }
} // pingreqFunctionsGroup

group pingrespFunctionsGroup
{
    function f_TC_MQTT_BROKER_PINGRESP_001() runs on MQTT_Client 
    {
      f_connectMqtt();
  
      var MQTT_v3_1_1_Message v_pingReq := valueof(t_ping_req('0000'B));
      f_send(v_pingReq);
  
      var template IPL4_Response v_expected := { receivedMsg := tw_ping_resp('0000'B) };
      var IPL4_Response v_response := f_receive();
  
      if(match(v_response, v_expected))
      {
        setverdict(pass, "IUT answered correctly to PINGREQ with ", v_response.receivedMsg);
      }
      else
      {
        setverdict(fail, "IUT answered incorrectly with ", v_response);
      }
  
      f_disconnectMqtt();
    }
} // pingrespFunctionsGroup

group disconnectFunctionsGroup
{
    function f_TC_MQTT_BROKER_DISCONNECT_001() runs on MQTT_Client 
    {
      f_connectMqtt();
  
      var MQTT_v3_1_1_Message v_disconnect := valueof(t_disconnect('0000'B));
      f_send(v_disconnect);
  
      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        // Note: this case should/will never occure!
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }
    }
    
    function f_TC_MQTT_BROKER_DISCONNECT_002() runs on MQTT_Client
    {
      f_connectMqtt();
  
      var MQTT_v3_1_1_Message v_disconnect := valueof(t_disconnect('1111'B));
      f_send(v_disconnect);
  
      if(f_receiveNetworkClosedEvent())
      {
        setverdict(pass, "IUT closed the Network Connection correctly");
      }
      else
      {
        // Note: this case should/will never occure!
        setverdict(fail, "IUT MUST close the Network Connection");
        f_disconnectMqtt();
      }      
    }
} // disconnectFunctionsGroup

}
